   Compiling caulk v0.1.0 (/home/caizhuo/code/caulk-updatable-lookup-argument-ccs24-local)
warning: unused import: `std::fmt::DebugMap`
 --> src/dft.rs:7:5
  |
7 | use std::fmt::DebugMap;
  |     ^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unused import: `Div`
 --> src/dft.rs:8:21
  |
8 | use std::ops::{Add, Div, Mul, Neg, Sub};
  |                     ^^^

warning: unused import: `PairingEngine`
 --> src/dft.rs:9:14
  |
9 | use ark_ec::{PairingEngine, ProjectiveCurve};
  |              ^^^^^^^^^^^^^

warning: unused import: `ark_serialize::CanonicalSerialize`
  --> src/dft.rs:15:5
   |
15 | use ark_serialize::CanonicalSerialize;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `std::ops::Neg`
   --> src/dft.rs:756:9
    |
756 |     use std::ops::Neg;
    |         ^^^^^^^^^^^^^

warning: unused import: `ark_ec::mnt4::G1Projective`
   --> src/dft.rs:760:9
    |
760 |     use ark_ec::mnt4::G1Projective;
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `ark_bn254::G2Affine`
  --> src/kzg.rs:20:5
   |
20 | use ark_bn254::G2Affine;
   |     ^^^^^^^^^^^^^^^^^^^

warning: unnecessary parentheses around assigned value
   --> src/kzg.rs:311:18
    |
311 |         status = (prod.is_one());
    |                  ^             ^
    |
    = note: `#[warn(unused_parens)]` on by default
help: remove these parentheses
    |
311 -         status = (prod.is_one());
311 +         status = prod.is_one();
    |

warning: unused import: `ark_bls12_377::g2`
 --> src/multi/setup.rs:2:5
  |
2 | use ark_bls12_377::g2;
  |     ^^^^^^^^^^^^^^^^^

warning: unused import: `ark_test_curves::pairing::Pairing`
  --> src/multi/setup.rs:12:5
   |
12 | use ark_test_curves::pairing::Pairing;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `ark_bls12_381::Bls12_381`
  --> src/multi/setup.rs:21:5
   |
21 | use ark_bls12_381::Bls12_381;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `ark_bn254::Bn254`
  --> src/multi/setup.rs:22:5
   |
22 | use ark_bn254::Bn254;
   |     ^^^^^^^^^^^^^^^^

warning: unused import: `std::marker::PhantomData`
 --> src/ramlookup/caulkplus.rs:4:5
  |
4 | use std::marker::PhantomData;
  |     ^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `ark_msm::msm::VariableBaseMSM`
 --> src/ramlookup/caulkplus.rs:8:5
  |
8 | use ark_msm::msm::VariableBaseMSM;
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused imports: `RngCore` and `Rng`
  --> src/ramlookup/caulkplus.rs:13:12
   |
13 | use rand::{Rng, RngCore};
   |            ^^^  ^^^^^^^

warning: unnecessary parentheses around assigned value
   --> src/ramlookup/caulkplus.rs:269:15
    |
269 |     let b_c = (lhs == rhs);
    |               ^          ^
    |
help: remove these parentheses
    |
269 -     let b_c = (lhs == rhs);
269 +     let b_c = lhs == rhs;
    |

warning: unnecessary parentheses around assigned value
   --> src/ramlookup/caulkplus.rs:276:21
    |
276 |     let b_opening = (E::pairing(u_com, g2) == E::pairing(proof.z_i_com, proof.g2_opening));
    |                     ^                                                                    ^
    |
help: remove these parentheses
    |
276 -     let b_opening = (E::pairing(u_com, g2) == E::pairing(proof.z_i_com, proof.g2_opening));
276 +     let b_opening = E::pairing(u_com, g2) == E::pairing(proof.z_i_com, proof.g2_opening);
    |

warning: unused import: `PrimeField`
   --> src/ramlookup/caulkplus.rs:697:25
    |
697 |     use ark_ff::{Field, PrimeField};
    |                         ^^^^^^^^^^

warning: unused import: `ark_bls12_381::Fr`
   --> src/ramlookup/caulkplus.rs:698:9
    |
698 |     use ark_bls12_381::Fr;
    |         ^^^^^^^^^^^^^^^^^

warning: unused import: `crate::multi::generate_lookup_input`
   --> src/ramlookup/caulkplus.rs:701:9
    |
701 |     use crate::multi::generate_lookup_input;
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `ark_ff::One`
   --> src/ramlookup/fastupdate.rs:379:9
    |
379 |     use ark_ff::One;
    |         ^^^^^^^^^^^

warning: unused import: `crate::multi::TableInput`
 --> src/ramlookup/cq.rs:1:5
  |
1 | use crate::multi::TableInput;
  |     ^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused imports: `CaulkPlusProverInput` and `CaulkPlusPublicParams`
 --> src/ramlookup/cq.rs:2:35
  |
2 | use crate::ramlookup::caulkplus::{CaulkPlusProverInput, CaulkPlusPublicParams};
  |                                   ^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `compute_scalar_coefficients_naive`
 --> src/ramlookup/cq.rs:4:34
  |
4 |     compute_scalar_coefficients, compute_scalar_coefficients_naive,
  |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `cfg_into_iter`
  --> src/ramlookup/cq.rs:13:15
   |
13 | use ark_std::{cfg_into_iter, UniformRand};
   |               ^^^^^^^^^^^^^

warning: unused import: `DivAssign`
  --> src/ramlookup/cq.rs:21:37
   |
21 | use std::ops::{Add, AddAssign, Div, DivAssign, Mul, MulAssign, Neg};
   |                                     ^^^^^^^^^

warning: unnecessary parentheses around method argument
    --> src/ramlookup/cq.rs:1115:45
     |
1115 |         let mut f = File::open(path).expect((format!("Unable to open file {path}").as_str()));
     |                                             ^                                              ^
     |
help: remove these parentheses
     |
1115 -         let mut f = File::open(path).expect((format!("Unable to open file {path}").as_str()));
1115 +         let mut f = File::open(path).expect(format!("Unable to open file {path}").as_str());
     |

warning: unnecessary parentheses around method argument
    --> src/ramlookup/cq.rs:1475:49
     |
1475 |             let mut f = File::open(path).expect((format!("Unable to open file {path}").as_str()));
     |                                                 ^                                              ^
     |
help: remove these parentheses
     |
1475 -             let mut f = File::open(path).expect((format!("Unable to open file {path}").as_str()));
1475 +             let mut f = File::open(path).expect(format!("Unable to open file {path}").as_str());
     |

warning: denote infinite loops with `loop { ... }`
    --> src/ramlookup/cq.rs:1650:13
     |
1650 |             while true {
     |             ^^^^^^^^^^ help: use `loop`
     |
     = note: `#[warn(while_true)]` on by default

warning: unnecessary parentheses around `if` condition
    --> src/ramlookup/cq.rs:2056:16
     |
2056 |             if (*log_k == 0) {
     |                ^           ^
     |
help: remove these parentheses
     |
2056 -             if (*log_k == 0) {
2056 +             if *log_k == 0 {
     |

warning: unused import: `std::marker::PhantomData`
 --> src/ramlookup/mod.rs:6:5
  |
6 | use std::marker::PhantomData;
  |     ^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `Neg`
 --> src/ramlookup/mod.rs:7:48
  |
7 | use std::ops::{AddAssign, Div, Mul, MulAssign, Neg, Sub};
  |                                                ^^^

warning: unused imports: `BigInteger` and `FftField`
 --> src/ramlookup/mod.rs:9:14
  |
9 | use ark_ff::{BigInteger, FftField, Field, One, PrimeField, Zero};
  |              ^^^^^^^^^^  ^^^^^^^^

warning: unused import: `kzg10`
  --> src/ramlookup/mod.rs:11:23
   |
11 | use ark_poly_commit::{kzg10, Polynomial, UVPolynomial};
   |                       ^^^^^

warning: unused import: `Proof`
  --> src/ramlookup/mod.rs:12:30
   |
12 | use ark_poly_commit::kzg10::{Proof, VerifierKey};
   |                              ^^^^^

warning: unused imports: `log2` and `test_rng`
  --> src/ramlookup/mod.rs:13:15
   |
13 | use ark_std::{log2, test_rng, time::Instant, UniformRand};
   |               ^^^^  ^^^^^^^^

warning: unused import: `merlin::Transcript`
  --> src/ramlookup/mod.rs:14:5
   |
14 | use merlin::Transcript;
   |     ^^^^^^^^^^^^^^^^^^

warning: unused imports: `LookupInstance`, `LookupProverInput`, `compute_lookup_proof`, `get_poly_and_g2_openings`, and `verify_lookup_proof`
  --> src/ramlookup/mod.rs:16:5
   |
16 |     compute_lookup_proof, get_poly_and_g2_openings, verify_lookup_proof, LookupInstance,
   |     ^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^^^^
17 |     LookupProverInput,
   |     ^^^^^^^^^^^^^^^^^

warning: unused import: `ark_ff::PrimeField`
    --> src/ramlookup/mod.rs:1118:9
     |
1118 |     use ark_ff::PrimeField;
     |         ^^^^^^^^^^^^^^^^^^

warning: unnecessary parentheses around `if` condition
    --> src/ramlookup/mod.rs:1288:16
     |
1288 |             if (tree[cur_node] >= level_threshold) {
     |                ^                                 ^
     |
help: remove these parentheses
     |
1288 -             if (tree[cur_node] >= level_threshold) {
1288 +             if tree[cur_node] >= level_threshold {
     |

warning: unused import: `AffineCurve`
   --> src/dft.rs:761:18
    |
761 |     use ark_ec::{AffineCurve, PairingEngine};
    |                  ^^^^^^^^^^^

warning: unused import: `ark_test_curves::pairing::Pairing`
  --> src/ramlookup/cq.rs:14:5
   |
14 | use ark_test_curves::pairing::Pairing;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: value assigned to `result` is never read
  --> src/dft.rs:47:13
   |
47 |     let mut result: DensePolynomial<F> = DensePolynomial::zero();
   |             ^^^^^^
   |
   = help: maybe it is overwritten before being read?
   = note: `#[warn(unused_assignments)]` on by default

warning: unused variable: `p`
  --> src/dft.rs:40:5
   |
40 |     p: usize,       // log of domain size
   |     ^ help: if this is intentional, prefix it with an underscore: `_p`
   |
   = note: `#[warn(unused_variables)]` on by default

warning: unused variable: `p`
  --> src/dft.rs:72:5
   |
72 |     p: usize,               // log of degree
   |     ^ help: if this is intentional, prefix it with an underscore: `_p`

warning: value assigned to `result` is never read
  --> src/dft.rs:97:13
   |
97 |     let mut result: DensePolynomial<F> = DensePolynomial::zero();
   |             ^^^^^^
   |
   = help: maybe it is overwritten before being read?

warning: unused variable: `i`
   --> src/dft.rs:101:9
    |
101 |     for i  in 0usize..(ark_std::log2(l) as usize)  {
    |         ^ help: if this is intentional, prefix it with an underscore: `_i`

warning: variable does not need to be mutable
   --> src/dft.rs:109:13
    |
109 |         let mut fred: DensePolynomial<F> = DensePolynomial::from_coefficients_vec(f_coeffs);
    |             ----^^^^
    |             |
    |             help: remove this `mut`
    |
    = note: `#[warn(unused_mut)]` on by default

warning: value assigned to `quotient` is never read
   --> src/dft.rs:135:13
    |
135 |     let mut quotient: DensePolynomial<F> = DensePolynomial::zero();
    |             ^^^^^^^^
    |
    = help: maybe it is overwritten before being read?

warning: value assigned to `remainder` is never read
   --> src/dft.rs:136:13
    |
136 |     let mut remainder: DensePolynomial<F> = DensePolynomial::zero();
    |             ^^^^^^^^^
    |
    = help: maybe it is overwritten before being read?

warning: value assigned to `quotient` is never read
   --> src/dft.rs:183:13
    |
183 |     let mut quotient: DensePolynomial<F> = DensePolynomial::zero();
    |             ^^^^^^^^
    |
    = help: maybe it is overwritten before being read?

warning: value assigned to `remainder` is never read
   --> src/dft.rs:184:13
    |
184 |     let mut remainder: DensePolynomial<F> = DensePolynomial::zero();
    |             ^^^^^^^^^
    |
    = help: maybe it is overwritten before being read?

warning: variable does not need to be mutable
   --> src/dft.rs:308:9
    |
308 |     let mut start = Instant::now();
    |         ----^^^^^
    |         |
    |         help: remove this `mut`

warning: unused variable: `a_poly`
   --> src/dft.rs:405:5
    |
405 |     a_poly: &DensePolynomial<F>,
    |     ^^^^^^ help: if this is intentional, prefix it with an underscore: `_a_poly`

warning: unused variable: `b_poly`
   --> src/dft.rs:406:5
    |
406 |     b_poly: &DensePolynomial<F>,
    |     ^^^^^^ help: if this is intentional, prefix it with an underscore: `_b_poly`

warning: unused variable: `i`
   --> src/dft.rs:814:13
    |
814 |         for i in 1..npolys {
    |             ^ help: if this is intentional, prefix it with an underscore: `_i`

warning: unused variable: `start`
   --> src/dft.rs:850:17
    |
850 |         let mut start = Instant::now();
    |                 ^^^^^ help: if this is intentional, prefix it with an underscore: `_start`

warning: unused variable: `prod`
   --> src/dft.rs:854:13
    |
854 |         let prod = VariableBaseMSM::multi_scalar_mul(grp_vec.as_slice(), scalar_vec.as_slice());
    |             ^^^^ help: if this is intentional, prefix it with an underscore: `_prod`

warning: variable does not need to be mutable
   --> src/dft.rs:850:13
    |
850 |         let mut start = Instant::now();
    |             ----^^^^^
    |             |
    |             help: remove this `mut`

warning: unused variable: `rng`
   --> src/dft.rs:868:17
    |
868 |         let mut rng = test_rng();
    |                 ^^^ help: if this is intentional, prefix it with an underscore: `_rng`

warning: variable does not need to be mutable
   --> src/dft.rs:868:13
    |
868 |         let mut rng = test_rng();
    |             ----^^^
    |             |
    |             help: remove this `mut`

warning: unused variable: `rng`
   --> src/dft.rs:878:17
    |
878 |         let mut rng = test_rng();
    |                 ^^^ help: if this is intentional, prefix it with an underscore: `_rng`

warning: variable does not need to be mutable
   --> src/dft.rs:878:13
    |
878 |         let mut rng = test_rng();
    |             ----^^^
    |             |
    |             help: remove this `mut`

warning: unused variable: `coeffs`
   --> src/dft.rs:901:13
    |
901 |         let coeffs: Vec<E::Fr> = vec![E::Fr::from(1u128), E::Fr::from(1u128), E::Fr::from(1u128)];
    |             ^^^^^^ help: if this is intentional, prefix it with an underscore: `_coeffs`

warning: unused variable: `points`
   --> src/dft.rs:902:13
    |
902 |         let points: Vec<E::Fr> = vec![
    |             ^^^^^^ help: if this is intentional, prefix it with an underscore: `_points`

warning: variable does not need to be mutable
   --> src/dft.rs:936:13
    |
936 |         let mut start = Instant::now();
    |             ----^^^^^
    |             |
    |             help: remove this `mut`

warning: unused variable: `i`
   --> src/dft.rs:954:13
    |
954 |         for i in 0..npolys {
    |             ^ help: if this is intentional, prefix it with an underscore: `_i`

warning: variable does not need to be mutable
   --> src/dft.rs:959:13
    |
959 |         let mut start = Instant::now();
    |             ----^^^^^
    |             |
    |             help: remove this `mut`

warning: value assigned to `status` is never read
   --> src/kzg.rs:298:17
    |
298 |         let mut status: bool  = false;
    |                 ^^^^^^
    |
    = help: maybe it is overwritten before being read?

warning: unused variable: `ptneg`
   --> src/kzg.rs:303:13
    |
303 |         let ptneg = -*point;
    |             ^^^^^ help: if this is intentional, prefix it with an underscore: `_ptneg`

warning: unused variable: `rhs`
   --> src/kzg.rs:305:13
    |
305 |         let rhs:E::G2Affine = g2x + g2.mul(-*point).into_affine();
    |             ^^^ help: if this is intentional, prefix it with an underscore: `_rhs`

warning: unused variable: `lhs`
   --> src/kzg.rs:306:13
    |
306 |         let lhs:E::G1Affine = *c_com + g1.mul(-*eval).into_affine();
    |             ^^^ help: if this is intentional, prefix it with an underscore: `_lhs`

warning: unused variable: `pi`
   --> src/kzg.rs:296:9
    |
296 |         pi: &E::G1Affine,
    |         ^^ help: if this is intentional, prefix it with an underscore: `_pi`

warning: value assigned to `res` is never read
   --> src/multi/setup.rs:261:17
    |
261 |         let mut res = File::open(path.clone());
    |                 ^^^
    |
    = help: maybe it is overwritten before being read?

warning: variable does not need to be mutable
   --> src/multi/setup.rs:297:21
    |
297 |                 let mut beta = E::Fr::rand(rng);
    |                     ----^^^^
    |                     |
    |                     help: remove this `mut`

warning: unused variable: `actual_degree`
   --> src/multi/mod.rs:753:13
    |
753 |         let actual_degree = N - 1;
    |             ^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_actual_degree`

warning: unused variable: `path`
   --> src/multi/mod.rs:754:13
    |
754 |         let path = format!("/tmp/poly_openings_{}.log", E::Fq::size_in_bits());
    |             ^^^^ help: if this is intentional, prefix it with an underscore: `_path`

warning: unused variable: `rng`
   --> src/multi/mod.rs:757:13
    |
757 |         let rng = &mut ark_std::test_rng();
    |             ^^^ help: if this is intentional, prefix it with an underscore: `_rng`

warning: unused variable: `c_com`
   --> src/multi/mod.rs:761:13
    |
761 |         let c_com = KZGCommit::<E>::commit_g1(&pp.poly_ck, &c_poly);
    |             ^^^^^ help: if this is intentional, prefix it with an underscore: `_c_com`

warning: unused variable: `openings`
   --> src/multi/mod.rs:764:13
    |
764 |         let openings = KZGCommit::<E>::multiple_open::<E::G2Affine>(&c_poly, &pp.g2_powers, pp.n);
    |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_openings`

warning: variable does not need to be mutable
   --> src/multi/mod.rs:760:13
    |
760 |         let mut start = Instant::now();
    |             ----^^^^^
    |             |
    |             help: remove this `mut`

warning: unused variable: `rng`
  --> src/ramlookup/caulkplus.rs:87:13
   |
87 |     let mut rng = ark_std::test_rng();
   |             ^^^ help: if this is intentional, prefix it with an underscore: `_rng`

warning: unused variable: `h_domain`
  --> src/ramlookup/caulkplus.rs:89:9
   |
89 |     let h_domain: GeneralEvaluationDomain<E::Fr> = GeneralEvaluationDomain::new(1 << instance.h_domain_size).unwrap();
   |         ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_h_domain`

warning: unused variable: `val_s`
   --> src/ramlookup/caulkplus.rs:156:10
    |
156 |     let (val_s, pi_s) = KZGCommit::<E>::open_g1_batch(
    |          ^^^^^ help: if this is intentional, prefix it with an underscore: `_val_s`

warning: variable does not need to be mutable
  --> src/ramlookup/caulkplus.rs:87:9
   |
87 |     let mut rng = ark_std::test_rng();
   |         ----^^^
   |         |
   |         help: remove this `mut`

warning: unused variable: `i`
   --> src/ramlookup/caulkplus.rs:488:13
    |
488 |         for i in 0..pp.g2_powers.len() {
    |             ^ help: if this is intentional, prefix it with an underscore: `_i`

warning: unused variable: `i`
   --> src/ramlookup/caulkplus.rs:567:9
    |
567 |     for i in 0..pp.g2_powers.len() {
    |         ^ help: if this is intentional, prefix it with an underscore: `_i`

warning: unused variable: `i`
   --> src/ramlookup/caulkplus.rs:602:9
    |
602 |     for i in 0..m {
    |         ^ help: if this is intentional, prefix it with an underscore: `_i`

warning: unused variable: `i`
   --> src/ramlookup/caulkplus.rs:609:9
    |
609 |     for i in a_vec.len()..m {
    |         ^ help: if this is intentional, prefix it with an underscore: `_i`

warning: unused variable: `rng`
   --> src/ramlookup/caulkplus.rs:635:13
    |
635 |     let mut rng = ark_std::test_rng();
    |             ^^^ help: if this is intentional, prefix it with an underscore: `_rng`

warning: variable does not need to be mutable
   --> src/ramlookup/caulkplus.rs:635:9
    |
635 |     let mut rng = ark_std::test_rng();
    |         ----^^^
    |         |
    |         help: remove this `mut`

warning: variable does not need to be mutable
   --> src/ramlookup/caulkplus.rs:636:9
    |
636 |     let mut i_vec = example.a_vec.clone();
    |         ----^^^^^
    |         |
    |         help: remove this `mut`

warning: variable does not need to be mutable
   --> src/ramlookup/caulkplus.rs:766:13
    |
766 |         let mut start = Instant::now();
    |             ----^^^^^
    |             |
    |             help: remove this `mut`

warning: unused variable: `z_i_poly`
   --> src/ramlookup/caulkplus.rs:803:50
    |
803 |         let (a_poly, v_poly, t_i_poly, l_i_poly, z_i_poly, h_poly) = (
    |                                                  ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_z_i_poly`

warning: variable does not need to be mutable
   --> src/ramlookup/caulkplus.rs:838:13
    |
838 |         let mut start = Instant::now();
    |             ----^^^^^
    |             |
    |             help: remove this `mut`

warning: unused variable: `i`
   --> src/ramlookup/caulkplus.rs:885:13
    |
885 |         for i in 0usize..1000 {
    |             ^ help: if this is intentional, prefix it with an underscore: `_i`

warning: unused variable: `domain_size`
   --> src/ramlookup/fastupdate.rs:355:5
    |
355 |     domain_size: usize,
    |     ^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_domain_size`

warning: unused variable: `i`
   --> src/ramlookup/fastupdate.rs:409:13
    |
409 |         for i in 0..i_set.len() {
    |             ^ help: if this is intentional, prefix it with an underscore: `_i`

warning: unused variable: `i`
   --> src/ramlookup/fastupdate.rs:413:13
    |
413 |         for i in 0..k_set.len() {
    |             ^ help: if this is intentional, prefix it with an underscore: `_i`

warning: unused variable: `evals_I`
   --> src/ramlookup/fastupdate.rs:464:13
    |
464 |         let evals_I = compute_reciprocal_sum(&t_j_vec, &k_set, &i_set, &h_domain, h_domain_size, &mut cache);
    |             ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_evals_I`

warning: unused variable: `evals_I_naive`
   --> src/ramlookup/fastupdate.rs:468:13
    |
468 |         let evals_I_naive = compute_reciprocal_sum_naive(&t_j_vec, &k_set, &i_set, &h_domain, h_domain_size);
    |             ^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_evals_I_naive`

warning: variable does not need to be mutable
   --> src/ramlookup/fastupdate.rs:462:13
    |
462 |         let mut start = Instant::now();
    |             ----^^^^^
    |             |
    |             help: remove this `mut`

warning: variable does not need to be mutable
   --> src/ramlookup/fastupdate.rs:467:13
    |
467 |         let mut start = Instant::now();
    |             ----^^^^^
    |             |
    |             help: remove this `mut`

warning: unused variable: `i`
   --> src/ramlookup/cq.rs:197:13
    |
197 |         for i in 0..(k - m) {
    |             ^ help: if this is intentional, prefix it with an underscore: `_i`

warning: unused variable: `i`
   --> src/ramlookup/cq.rs:206:13
    |
206 |         for i in 0..m {
    |             ^ help: if this is intentional, prefix it with an underscore: `_i`

warning: variable does not need to be mutable
   --> src/ramlookup/cq.rs:238:13
    |
238 |         let mut i_set_vec: Vec<usize> = m_set.clone().into_iter().collect::<Vec<_>>();
    |             ----^^^^^^^^^
    |             |
    |             help: remove this `mut`

warning: unused variable: `i`
   --> src/ramlookup/cq.rs:314:13
    |
314 |         for i in 0..(k - m) {
    |             ^ help: if this is intentional, prefix it with an underscore: `_i`

warning: variable does not need to be mutable
   --> src/ramlookup/cq.rs:343:13
    |
343 |         let mut i_set_vec: Vec<usize> = m_set.clone().into_iter().collect::<Vec<_>>();
    |             ----^^^^^^^^^
    |             |
    |             help: remove this `mut`

warning: variable does not need to be mutable
   --> src/ramlookup/cq.rs:459:13
    |
459 |         let mut i_set_vec: Vec<usize> = m_set.clone().into_iter().collect::<Vec<_>>();
    |             ----^^^^^^^^^
    |             |
    |             help: remove this `mut`

warning: variable does not need to be mutable
   --> src/ramlookup/cq.rs:698:9
    |
698 |     let mut start = Instant::now();
    |         ----^^^^^
    |         |
    |         help: remove this `mut`

warning: unused variable: `i`
    --> src/ramlookup/cq.rs:1345:13
     |
1345 |         for i in 0..pp.poly_ck.powers_of_g.len() {
     |             ^ help: if this is intentional, prefix it with an underscore: `_i`

warning: unused variable: `g2`
    --> src/ramlookup/cq.rs:1349:13
     |
1349 |         let g2 = pp.g2_powers[0];
     |             ^^ help: if this is intentional, prefix it with an underscore: `_g2`

warning: unused variable: `i`
    --> src/ramlookup/cq.rs:1435:17
     |
1435 |             for i in 0..pp.poly_ck.powers_of_g.len() {
     |                 ^ help: if this is intentional, prefix it with an underscore: `_i`

warning: unused variable: `o_bytes`
    --> src/ramlookup/cq.rs:1494:21
     |
1494 |             let mut o_bytes = Vec::<u8>::new();
     |                     ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_o_bytes`

warning: unused variable: `h_domain_size`
    --> src/ramlookup/cq.rs:1469:33
     |
1469 | fn load_table_or_new(N: &usize, h_domain_size: &usize, path: &str) -> Vec<usize> {
     |                                 ^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_h_domain_size`

warning: variable does not need to be mutable
    --> src/ramlookup/cq.rs:1494:17
     |
1494 |             let mut o_bytes = Vec::<u8>::new();
     |                 ----^^^^^^^
     |                 |
     |                 help: remove this `mut`

warning: variable does not need to be mutable
    --> src/ramlookup/cq.rs:1552:13
     |
1552 |         let mut base_table: Vec<usize> = load_table_or_new(&N, &h, &path);
     |             ----^^^^^^^^^^
     |             |
     |             help: remove this `mut`

warning: unused variable: `rng`
    --> src/ramlookup/cq.rs:1644:21
     |
1644 |             let mut rng = ark_std::test_rng();
     |                     ^^^ help: if this is intentional, prefix it with an underscore: `_rng`

warning: unused variable: `cq_pp`
    --> src/ramlookup/cq.rs:1666:17
     |
1666 |             let cq_pp: CqPublicParams<E> = CqPublicParams::load(_h_domain_size);
     |                 ^^^^^ help: if this is intentional, prefix it with an underscore: `_cq_pp`

warning: value assigned to `table_pp` is never read
    --> src/ramlookup/cq.rs:1697:21
     |
1697 |                     table_pp = CqProverInput::load_by_path(&table_pp_path)
     |                     ^^^^^^^^
     |
     = help: maybe it is overwritten before being read?

warning: variable does not need to be mutable
    --> src/ramlookup/cq.rs:1644:17
     |
1644 |             let mut rng = ark_std::test_rng();
     |                 ----^^^
     |                 |
     |                 help: remove this `mut`

warning: variable does not need to be mutable
    --> src/ramlookup/cq.rs:1675:17
     |
1675 |             let mut base_table: Vec<usize> = load_table_or_new(&N, &_h_domain_size, &path);
     |                 ----^^^^^^^^^^
     |                 |
     |                 help: remove this `mut`

warning: variable does not need to be mutable
    --> src/ramlookup/cq.rs:1685:17
     |
1685 |             let mut start = Instant::now();
     |                 ----^^^^^
     |                 |
     |                 help: remove this `mut`

warning: unused variable: `cq_pp`
    --> src/ramlookup/cq.rs:1735:21
     |
1735 |                 let cq_pp: CqPublicParams<E> = CqPublicParams::new(&pp, log_table_sizes[i], false);
     |                     ^^^^^ help: if this is intentional, prefix it with an underscore: `_cq_pp`

warning: unused variable: `table_pp`
    --> src/ramlookup/cq.rs:1772:21
     |
1772 |                 let table_pp =
     |                     ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_table_pp`

warning: unused variable: `pos`
    --> src/ramlookup/cq.rs:1860:29
     |
1860 |                         let pos = f_vec.push(
     |                             ^^^ help: if this is intentional, prefix it with an underscore: `_pos`

warning: unused variable: `proof`
    --> src/ramlookup/cq.rs:1918:25
     |
1918 |                     let proof = compute_cq_proof::<E>(
     |                         ^^^^^ help: if this is intentional, prefix it with an underscore: `_proof`

warning: value assigned to `prev_lookup_time` is never read
    --> src/ramlookup/cq.rs:1931:29
     |
1931 |                     let mut prev_lookup_time = 0.0 as f64;
     |                             ^^^^^^^^^^^^^^^^
     |
     = help: maybe it is overwritten before being read?

warning: variable does not need to be mutable
    --> src/ramlookup/cq.rs:1841:25
     |
1841 |                     let mut delta = batch_size << d_k;
     |                         ----^^^^^
     |                         |
     |                         help: remove this `mut`

warning: variable does not need to be mutable
    --> src/ramlookup/cq.rs:2019:13
     |
2019 |         let mut base_table: Vec<usize> = load_table_or_new(&N, &_h_domain_size, &path);
     |             ----^^^^^^^^^^
     |             |
     |             help: remove this `mut`

warning: variable does not need to be mutable
    --> src/ramlookup/cq.rs:2090:17
     |
2090 |             let mut timer_tcom = Instant::now();
     |                 ----^^^^^^^^^^
     |                 |
     |                 help: remove this `mut`

warning: unused variable: `g1x`
    --> src/ramlookup/cq.rs:2199:13
     |
2199 |         let g1x = pp.poly_ck.powers_of_g[1];
     |             ^^^ help: if this is intentional, prefix it with an underscore: `_g1x`

warning: unused variable: `i`
    --> src/ramlookup/cq.rs:2203:13
     |
2203 |         for i in 0usize..1000 {
     |             ^ help: if this is intentional, prefix it with an underscore: `_i`

warning: variable does not need to be mutable
    --> src/ramlookup/cq.rs:2252:13
     |
2252 |         let mut start = Instant::now();
     |             ----^^^^^
     |             |
     |             help: remove this `mut`

warning: unused variable: `i`
  --> src/ramlookup/mod.rs:67:9
   |
67 |     for i in 0..vec_size {
   |         ^ help: if this is intentional, prefix it with an underscore: `_i`

warning: value assigned to `proof` is never read
   --> src/ramlookup/mod.rs:320:13
    |
320 |     let mut proof: Option<ProofConcat<E>> = None;
    |             ^^^^^
    |
    = help: maybe it is overwritten before being read?

warning: unused variable: `g_com`
   --> src/ramlookup/mod.rs:412:9
    |
412 |     let g_com = KZGCommit::commit_g1(&pp.poly_ck, &g_poly);
    |         ^^^^^ help: if this is intentional, prefix it with an underscore: `_g_com`

warning: value assigned to `status` is never read
   --> src/ramlookup/mod.rs:447:13
    |
447 |     let mut status: bool = false;
    |             ^^^^^^
    |
    = help: maybe it is overwritten before being read?

warning: unused variable: `m_domain`
   --> src/ramlookup/mod.rs:553:13
    |
553 |         let m_domain = GeneralEvaluationDomain::<E::Fr>::new(m).unwrap();
    |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_m_domain`

warning: unused variable: `pp`
   --> src/ramlookup/mod.rs:750:5
    |
750 |     pp: &PublicParameters<E>
    |     ^^ help: if this is intentional, prefix it with an underscore: `_pp`

warning: unused variable: `m_domain`
   --> src/ramlookup/mod.rs:852:9
    |
852 |     let m_domain: GeneralEvaluationDomain<E::Fr> = GeneralEvaluationDomain::new(m).unwrap();
    |         ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_m_domain`

warning: unused variable: `val_s`
   --> src/ramlookup/mod.rs:964:10
    |
964 |     let (val_s, proof_s) = KZGCommit::<E>::open_g1_batch(
    |          ^^^^^ help: if this is intentional, prefix it with an underscore: `_val_s`

warning: unused variable: `val_ws`
   --> src/ramlookup/mod.rs:971:10
    |
971 |     let (val_ws, proof_ws) = KZGCommit::<E>::open_g1_batch(
    |          ^^^^^^ help: if this is intentional, prefix it with an underscore: `_val_ws`

warning: unused variable: `k_domain_size`
    --> src/ramlookup/mod.rs:1130:13
     |
1130 |         let k_domain_size: usize = 9;
     |             ^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_k_domain_size`

warning: unused variable: `proof`
    --> src/ramlookup/mod.rs:1149:13
     |
1149 |         let proof = compute_monotonic_proof::<E>(
     |             ^^^^^ help: if this is intentional, prefix it with an underscore: `_proof`

warning: variable does not need to be mutable
    --> src/ramlookup/mod.rs:1148:13
     |
1148 |         let mut start = Instant::now();
     |             ----^^^^^
     |             |
     |             help: remove this `mut`

warning: unused variable: `rng`
    --> src/ramlookup/mod.rs:1161:17
     |
1161 |         let mut rng = ark_std::test_rng();
     |                 ^^^ help: if this is intentional, prefix it with an underscore: `_rng`

warning: unused variable: `n_domain_size`
    --> src/ramlookup/mod.rs:1165:13
     |
1165 |         let n_domain_size: usize = 0;
     |             ^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_n_domain_size`

warning: unused variable: `k`
    --> src/ramlookup/mod.rs:1169:13
     |
1169 |         let k: usize = 1 << k_domain_size;
     |             ^ help: if this is intentional, prefix it with an underscore: `_k`

warning: variable does not need to be mutable
    --> src/ramlookup/mod.rs:1161:13
     |
1161 |         let mut rng = ark_std::test_rng();
     |             ----^^^
     |             |
     |             help: remove this `mut`

warning: value assigned to `cost` is never read
    --> src/ramlookup/mod.rs:1270:17
     |
1270 |         let mut cost: f64 = 0.0;
     |                 ^^^^
     |
     = help: maybe it is overwritten before being read?

warning: unused variable: `j`
    --> src/ramlookup/mod.rs:1278:17
     |
1278 |             for j in 0..depth {
     |                 ^ help: if this is intentional, prefix it with an underscore: `_j`

warning: struct `CommittedRAM` is never constructed
  --> src/ramlookup/mod.rs:30:12
   |
30 | pub struct CommittedRAM<E: PairingEngine> {
   |            ^^^^^^^^^^^^
   |
   = note: `#[warn(dead_code)]` on by default

warning: struct `OperationBatch` is never constructed
  --> src/ramlookup/mod.rs:35:12
   |
35 | pub struct OperationBatch<E: PairingEngine> {
   |            ^^^^^^^^^^^^^^

warning: struct `ProverInputCommon` is never constructed
   --> src/ramlookup/mod.rs:165:12
    |
165 | pub struct ProverInputCommon<E: PairingEngine> {
    |            ^^^^^^^^^^^^^^^^^

warning: struct `VerifierInputCommon` is never constructed
   --> src/ramlookup/mod.rs:175:12
    |
175 | pub struct VerifierInputCommon<E: PairingEngine> {
    |            ^^^^^^^^^^^^^^^^^^^

warning: multiple fields are never read
   --> src/ramlookup/mod.rs:527:9
    |
526 | pub struct MonotonicTranscriptExample<E: PairingEngine> {
    |            -------------------------- fields in this struct
527 |     pub a_vec: Vec<usize>,
    |         ^^^^^
528 |     pub v_vec: Vec<usize>,
    |         ^^^^^
529 |     pub a_dash_vec: Vec<usize>,
    |         ^^^^^^^^^^
530 |     pub v_dash_vec: Vec<usize>,
    |         ^^^^^^^^^^
531 |     pub op_vec: Vec<usize>,
    |         ^^^^^^
532 |     pub a_bar_vec: Vec<usize>,
    |         ^^^^^^^^^
533 |     pub v_bar_vec: Vec<usize>,
    |         ^^^^^^^^^
...
538 |     pub tr: RAMTranscript<E>,
    |         ^^
...
541 |     pub addr_tr_com: RAMTranscriptCom<E>,
    |         ^^^^^^^^^^^
542 |     pub m_domain_size: usize,
543 |     pub h_domain_size: usize,
    |         ^^^^^^^^^^^^^

warning: multiple fields are never read
   --> src/ramlookup/mod.rs:703:9
    |
702 | pub struct ProofMonotonic<E: PairingEngine> {
    |            -------------- fields in this struct
703 |     pub z1_com: E::G1Affine,
    |         ^^^^^^
704 |     pub z2_com: E::G1Affine,
    |         ^^^^^^
705 |     pub delta_A_com: E::G1Affine,
    |         ^^^^^^^^^^^
706 |     pub delta_T_com: E::G1Affine,
    |         ^^^^^^^^^^^
707 |     pub q1_com: E::G1Affine,
    |         ^^^^^^
708 |     pub q2_com: E::G1Affine,
    |         ^^^^^^
709 |
710 |     pub val_A_s: E::Fr,
    |         ^^^^^^^
711 |     pub val_A_ws: E::Fr,
    |         ^^^^^^^^
712 |     pub val_deltaA_s: E::Fr,
    |         ^^^^^^^^^^^^
713 |     pub val_deltaT_s: E::Fr,
    |         ^^^^^^^^^^^^
714 |     pub val_T_s: E::Fr,
    |         ^^^^^^^
715 |     pub val_T_ws: E::Fr,
    |         ^^^^^^^^
716 |     pub val_op_ws: E::Fr,
    |         ^^^^^^^^^
717 |     pub val_V_s: E::Fr,
    |         ^^^^^^^
718 |     pub val_V_ws: E::Fr,
    |         ^^^^^^^^
719 |     pub val_Q1_s: E::Fr,
    |         ^^^^^^^^
720 |     pub val_Q2_s: E::Fr,
    |         ^^^^^^^^
721 |     pub val_Z1_s: E::Fr,
    |         ^^^^^^^^
722 |     pub val_Z2_s: E::Fr,
    |         ^^^^^^^^
723 |
724 |     pub pi_s: E::G1Affine,
    |         ^^^^
725 |     pub pi_ws: E::G1Affine,
    |         ^^^^^
726 |
727 |     pub range_proof_A: CqProof<E>,
    |         ^^^^^^^^^^^^^
728 |     pub range_proof_deltaA: CqProof<E>,
    |         ^^^^^^^^^^^^^^^^^^
729 |     pub range_proof_deltaT: CqProof<E>,
    |         ^^^^^^^^^^^^^^^^^^
730 |     pub range_proof_t: CqProof<E>
    |         ^^^^^^^^^^^^^

warning: fields `set_I1` and `set_I2` are never read
   --> src/ramlookup/mod.rs:735:9
    |
734 | pub struct ProofMonotonicProverInput<E: PairingEngine> {
    |            ------------------------- fields in this struct
735 |     pub set_I1: Vec<usize>,
    |         ^^^^^^
736 |     pub set_I2: Vec<usize>,
    |         ^^^^^^

warning: field `t_poly` is never read
  --> src/ramlookup/caulkplus.rs:32:9
   |
30 | pub struct CaulkPlusProverInput<E: PairingEngine> {
   |            -------------------- field in this struct
31 |     pub t_com: E::G1Affine,                          // commitment to table
32 |     pub t_poly: DensePolynomial<E::Fr>,             // polynomial interpolating the table on h_domain
   |         ^^^^^^

warning: method `store` is never used
   --> src/ramlookup/caulkplus.rs:284:12
    |
282 | impl<E: PairingEngine> CaulkPlusProverInput<E> {
    | ---------------------------------------------- method in this implementation
283 |     // store the prover input in a file
284 |     pub fn store(&self, h_domain_size: usize) {
    |            ^^^^^

warning: associated function `new` is never used
   --> src/ramlookup/caulkplus.rs:412:12
    |
323 | impl<E: PairingEngine> CaulkPlusPublicParams<E> {
    | ----------------------------------------------- associated function in this implementation
...
412 |     pub fn new(
    |            ^^^

warning: field `zk_dvt_poly` is never read
  --> src/ramlookup/fastupdate.rs:12:9
   |
8  | pub struct UpdateParamsSetK<F: PrimeField> {
   |            ---------------- field in this struct
...
12 |     pub zk_dvt_poly: DensePolynomial<F>,    // derivative of Z_K
   |         ^^^^^^^^^^^

warning: field `pi_h` is never read
   --> src/ramlookup/cq.rs:147:9
    |
135 | pub struct CqProof<E: PairingEngine> {
    |            ------- field in this struct
...
147 |     pub pi_h: E::G1Affine,    // evaluation proof for h(\gamma).
    |         ^^^^

warning: field `b_poly` is never read
   --> src/ramlookup/cq.rs:751:9
    |
747 | pub struct CqLookupInputRound2<E: PairingEngine> {
    |            ------------------- field in this struct
...
751 |     pub b_poly: DensePolynomial<E::Fr>,    // B polynomial interpolating 1/(beta + f_i)
    |         ^^^^^^

warning: field `h_poly` is never read
   --> src/ramlookup/cq.rs:763:9
    |
762 | pub struct CqLookupInputRound3<E: PairingEngine> {
    |            ------------------- field in this struct
763 |     pub h_poly: DensePolynomial<E::Fr>, // h = B0 + \eta f + \eta^2 Q_B
    |         ^^^^^^

warning: variable `rand_A_polys` should have a snake case name
   --> src/dft.rs:950:17
    |
950 |         let mut rand_A_polys: Vec<DensePolynomial<E::Fr>> = Vec::new();
    |                 ^^^^^^^^^^^^ help: convert the identifier to snake case: `rand_a_polys`
    |
    = note: `#[warn(non_snake_case)]` on by default

warning: variable `rand_B_polys` should have a snake case name
   --> src/dft.rs:951:17
    |
951 |         let mut rand_B_polys: Vec<DensePolynomial<E::Fr>> = Vec::new();
    |                 ^^^^^^^^^^^^ help: convert the identifier to snake case: `rand_b_polys`

warning: variable `rand_C_polys` should have a snake case name
   --> src/dft.rs:952:17
    |
952 |         let mut rand_C_polys: Vec<DensePolynomial<E::Fr>> = Vec::new();
    |                 ^^^^^^^^^^^^ help: convert the identifier to snake case (notice the capitalization): `rand_c_polys`

warning: variable `fft_C` should have a snake case name
   --> src/dft.rs:981:17
    |
981 |         let mut fft_C: Vec<E::Fr> = Vec::with_capacity(1usize << 21);
    |                 ^^^^^ help: convert the identifier to snake case (notice the capitalization): `fft_c`

warning: variable `fft_A` should have a snake case name
   --> src/dft.rs:985:17
    |
985 |             let fft_A: Vec<E::Fr> = field_fft_domain(&rand_A_polys[i].coeffs, 21, &input_domain);
    |                 ^^^^^ help: convert the identifier to snake case: `fft_a`

warning: variable `fft_B` should have a snake case name
   --> src/dft.rs:986:17
    |
986 |             let fft_B: Vec<E::Fr> = field_fft_domain(&rand_B_polys[i].coeffs, 21, &input_domain);
    |                 ^^^^^ help: convert the identifier to snake case: `fft_b`

warning: variable `delta_A_poly` should have a snake case name
   --> src/ramlookup/mod.rs:112:5
    |
112 |     delta_A_poly: &DensePolynomial<E::Fr>,
    |     ^^^^^^^^^^^^ help: convert the identifier to snake case: `delta_a_poly`

warning: variable `delta_T_poly` should have a snake case name
   --> src/ramlookup/mod.rs:113:5
    |
113 |     delta_T_poly: &DensePolynomial<E::Fr>,
    |     ^^^^^^^^^^^^ help: convert the identifier to snake case: `delta_t_poly`

warning: variable `dA_poly` should have a snake case name
   --> src/ramlookup/mod.rs:120:9
    |
120 |     let dA_poly:DensePolynomial<E::Fr> = compute_shifted_difference::<E>(&a_poly, k_domain_size);
    |         ^^^^^^^ help: convert the identifier to snake case: `d_a_poly`

warning: variable `dT_poly` should have a snake case name
   --> src/ramlookup/mod.rs:121:9
    |
121 |     let dT_poly: DensePolynomial<E::Fr> = compute_shifted_difference::<E>(&t_poly, k_domain_size);
    |         ^^^^^^^ help: convert the identifier to snake case: `d_t_poly`

warning: variable `dV_poly` should have a snake case name
   --> src/ramlookup/mod.rs:122:9
    |
122 |     let dV_poly: DensePolynomial<E::Fr> = compute_shifted_difference::<E>(&v_poly, k_domain_size);
    |         ^^^^^^^ help: convert the identifier to snake case: `d_v_poly`

warning: variable `dOp_poly` should have a snake case name
   --> src/ramlookup/mod.rs:123:9
    |
123 |     let dOp_poly: DensePolynomial<E::Fr> = compute_shifted_difference::<E>(&op_poly, k_domain_size);
    |         ^^^^^^^^ help: convert the identifier to snake case: `d_op_poly`

warning: variable `dA_dash_poly` should have a snake case name
   --> src/ramlookup/mod.rs:126:9
    |
126 |     let dA_dash_poly:DensePolynomial<E::Fr> = dA_poly.sub(delta_A_poly);
    |         ^^^^^^^^^^^^ help: convert the identifier to snake case: `d_a_dash_poly`

warning: variable `dT_dash_poly` should have a snake case name
   --> src/ramlookup/mod.rs:131:9
    |
131 |     let dT_dash_poly: DensePolynomial<E::Fr> = dT_poly.sub(delta_T_poly);
    |         ^^^^^^^^^^^^ help: convert the identifier to snake case: `d_t_dash_poly`

warning: variable `op_dV_poly` should have a snake case name
   --> src/ramlookup/mod.rs:135:9
    |
135 |     let op_dV_poly: DensePolynomial<E::Fr> = &op_dash_poly * &dV_poly;
    |         ^^^^^^^^^^ help: convert the identifier to snake case: `op_d_v_poly`

warning: variable `op_dV_poly` should have a snake case name
   --> src/ramlookup/mod.rs:136:9
    |
136 |     let op_dV_poly = compute_scaled_polynomial::<E>(&op_dV_poly, gamma_sq);
    |         ^^^^^^^^^^ help: convert the identifier to snake case: `op_d_v_poly`

warning: variable `N_inv` should have a snake case name
   --> src/ramlookup/caulkplus.rs:447:13
    |
447 |         let N_inv = E::Fr::from(h_domain.size() as u128).inverse().unwrap();
    |             ^^^^^ help: convert the identifier to snake case: `n_inv`

warning: variable `N_inv` should have a snake case name
   --> src/ramlookup/caulkplus.rs:517:13
    |
517 |         let N_inv = E::Fr::from(h_domain.size() as u128).inverse().unwrap();
    |             ^^^^^ help: convert the identifier to snake case: `n_inv`

warning: variable `N` should have a snake case name
   --> src/ramlookup/caulkplus.rs:551:9
    |
551 |     let N: usize = t_vec.len();
    |         ^ help: convert the identifier to snake case: `n`

warning: constant `h_domain_size` should have an upper case name
   --> src/ramlookup/caulkplus.rs:703:11
    |
703 |     const h_domain_size: usize = 22;
    |           ^^^^^^^^^^^^^ help: convert the identifier to upper case: `H_DOMAIN_SIZE`
    |
    = note: `#[warn(non_upper_case_globals)]` on by default

warning: constant `m_domain_size` should have an upper case name
   --> src/ramlookup/caulkplus.rs:704:11
    |
704 |     const m_domain_size: usize = 11;
    |           ^^^^^^^^^^^^^ help: convert the identifier to upper case: `M_DOMAIN_SIZE`

warning: variable `N` should have a snake case name
   --> src/ramlookup/caulkplus.rs:733:13
    |
733 |         let N: usize = 1 << h_domain_size;
    |             ^ help: convert the identifier to snake case: `n`

warning: variable `N` should have a snake case name
   --> src/ramlookup/caulkplus.rs:788:13
    |
788 |         let N: usize = 1 << h_domain_size;
    |             ^ help: convert the identifier to snake case: `n`

warning: variable `N` should have a snake case name
   --> src/ramlookup/caulkplus.rs:827:13
    |
827 |         let N: usize = 1 << h_domain_size;
    |             ^ help: convert the identifier to snake case: `n`

warning: variable `N` should have a snake case name
   --> src/ramlookup/caulkplus.rs:868:13
    |
868 |         let N: usize = 1 << h_domain_size;
    |             ^ help: convert the identifier to snake case: `n`

warning: variable `N_inv` should have a snake case name
   --> src/ramlookup/caulkplus.rs:895:17
    |
895 |             let N_inv = E::Fr::from(N as u128).inverse().unwrap();
    |                 ^^^^^ help: convert the identifier to snake case: `n_inv`

warning: variable `N` should have a snake case name
  --> src/ramlookup/fastupdate.rs:66:13
   |
66 |         let N = 1usize << h_domain_size;
   |             ^ help: convert the identifier to snake case: `n`

warning: variable `field_N` should have a snake case name
  --> src/ramlookup/fastupdate.rs:67:13
   |
67 |         let field_N = F::from(N as u128);
   |             ^^^^^^^ help: convert the identifier to snake case: `field_n`

warning: variable `field_N1` should have a snake case name
  --> src/ramlookup/fastupdate.rs:68:13
   |
68 |         let field_N1 = F::from( ((N*(N-1))/2) as u128);
   |             ^^^^^^^^ help: convert the identifier to snake case: `field_n1`

warning: variable `z_I` should have a snake case name
   --> src/ramlookup/fastupdate.rs:194:9
    |
194 |     let z_I = compute_vanishing_poly::<F>(&h_i_vec, 1);
    |         ^^^ help: convert the identifier to snake case (notice the capitalization): `z_i`

warning: variable `z_I_dvt_evals_I` should have a snake case name
   --> src/ramlookup/fastupdate.rs:201:9
    |
201 |     let z_I_dvt_evals_I = fast_poly_evaluate(zi_dvt_coeffs.as_slice(), &h_i_vec);
    |         ^^^^^^^^^^^^^^^ help: convert the identifier to snake case (notice the capitalization): `z_i_dvt_evals_i`

warning: variable `z_I_evals_K` should have a snake case name
   --> src/ramlookup/fastupdate.rs:205:9
    |
205 |     let z_I_evals_K = fast_poly_evaluate_with_pp(
    |         ^^^^^^^^^^^ help: convert the identifier to snake case (notice the capitalization): `z_i_evals_k`

warning: variable `c_evals_K` should have a snake case name
   --> src/ramlookup/fastupdate.rs:232:9
    |
232 |     let c_evals_K = fast_poly_evaluate_with_pp(
    |         ^^^^^^^^^ help: convert the identifier to snake case (notice the capitalization): `c_evals_k`

warning: variable `N` should have a snake case name
   --> src/ramlookup/fastupdate.rs:269:9
    |
269 |     let N = domain.size();
    |         ^ help: convert the identifier to snake case: `n`

warning: variable `q_evals_K` should have a snake case name
   --> src/ramlookup/fastupdate.rs:284:13
    |
284 |     let mut q_evals_K: Vec<F> = Vec::new();
    |             ^^^^^^^^^ help: convert the identifier to snake case (notice the capitalization): `q_evals_k`

warning: variable `q_dvt_evals_K` should have a snake case name
   --> src/ramlookup/fastupdate.rs:314:9
    |
314 |     let q_dvt_evals_K = fast_poly_evaluate(q_poly_dvt_coeffs.as_slice(), h_i_vec.as_slice());
    |         ^^^^^^^^^^^^^ help: convert the identifier to snake case (notice the capitalization): `q_dvt_evals_k`

warning: variable `p_dvt_evals_I` should have a snake case name
   --> src/ramlookup/fastupdate.rs:318:13
    |
318 |     let mut p_dvt_evals_I: Vec<F> = Vec::new();
    |             ^^^^^^^^^^^^^ help: convert the identifier to snake case (notice the capitalization): `p_dvt_evals_i`

warning: variable `fN` should have a snake case name
   --> src/ramlookup/fastupdate.rs:325:9
    |
325 |     let fN = F::from(N as u128);
    |         ^^ help: convert the identifier to snake case: `f_n`

warning: variable `fN1` should have a snake case name
   --> src/ramlookup/fastupdate.rs:326:9
    |
326 |     let fN1 = F::from((N-1) as u128).div(F::from(2u128));
    |         ^^^ help: convert the identifier to snake case: `f_n1`

warning: variable `e_evals_I` should have a snake case name
   --> src/ramlookup/fastupdate.rs:327:13
    |
327 |     let mut e_evals_I: Vec<F> = Vec::new();
    |             ^^^^^^^^^ help: convert the identifier to snake case (notice the capitalization): `e_evals_i`

warning: variable `e_evals_I` should have a snake case name
   --> src/ramlookup/fastupdate.rs:358:13
    |
358 |     let mut e_evals_I: Vec<F> = Vec::new();
    |             ^^^^^^^^^ help: convert the identifier to snake case (notice the capitalization): `e_evals_i`

warning: variable `evals_I` should have a snake case name
   --> src/ramlookup/fastupdate.rs:464:13
    |
464 |         let evals_I = compute_reciprocal_sum(&t_j_vec, &k_set, &i_set, &h_domain, h_domain_size, &mut cache);
    |             ^^^^^^^ help: convert the identifier to snake case (notice the capitalization): `evals_i`

warning: variable `evals_I_naive` should have a snake case name
   --> src/ramlookup/fastupdate.rs:468:13
    |
468 |         let evals_I_naive = compute_reciprocal_sum_naive(&t_j_vec, &k_set, &i_set, &h_domain, h_domain_size);
    |             ^^^^^^^^^^^^^ help: convert the identifier to snake case (notice the capitalization): `evals_i_naive`

warning: variable `N` should have a snake case name
   --> src/ramlookup/cq.rs:671:9
    |
671 |     let N: usize = 1usize << h_domain_size;
    |         ^ help: convert the identifier to snake case: `n`

warning: structure field `sparse_A_vec` should have a snake case name
   --> src/ramlookup/cq.rs:748:9
    |
748 |     pub sparse_A_vec: Vec<(usize, E::Fr)>, // sparse A polynomial
    |         ^^^^^^^^^^^^ help: convert the identifier to snake case: `sparse_a_vec`

warning: variable `N` should have a snake case name
   --> src/ramlookup/cq.rs:781:9
    |
781 |     let N = domain.size();
    |         ^ help: convert the identifier to snake case: `n`

warning: variable `N` should have a snake case name
   --> src/ramlookup/cq.rs:865:9
    |
865 |     let N = h_domain.size();
    |         ^ help: convert the identifier to snake case: `n`

warning: variable `N_inv` should have a snake case name
    --> src/ramlookup/cq.rs:1299:21
     |
1299 |                 let N_inv = E::Fr::from(h_domain.size() as u128).inverse().unwrap();
     |                     ^^^^^ help: convert the identifier to snake case: `n_inv`

warning: variable `N_inv` should have a snake case name
    --> src/ramlookup/cq.rs:1375:13
     |
1375 |         let N_inv = E::Fr::from(h_domain.size() as u128).inverse().unwrap();
     |             ^^^^^ help: convert the identifier to snake case: `n_inv`

warning: variable `N` should have a snake case name
    --> src/ramlookup/cq.rs:1412:9
     |
1412 |     let N: usize = t_vec.len();
     |         ^ help: convert the identifier to snake case: `n`

warning: variable `N` should have a snake case name
    --> src/ramlookup/cq.rs:1469:22
     |
1469 | fn load_table_or_new(N: &usize, h_domain_size: &usize, path: &str) -> Vec<usize> {
     |                      ^ help: convert the identifier to snake case: `n`

warning: call to `.clone()` on a reference in this situation does nothing
    --> src/ramlookup/cq.rs:1471:30
     |
1471 |     let res = File::open(path.clone());
     |                              ^^^^^^^^ help: remove this redundant call
     |
     = note: the type `str` does not implement `Clone`, so calling `clone` on `&str` copies the reference, which does not do anything and can be removed
     = note: `#[warn(noop_method_call)]` on by default

warning: constant `h_domain_size` should have an upper case name
    --> src/ramlookup/cq.rs:1518:11
     |
1518 |     const h_domain_size: usize = 18;
     |           ^^^^^^^^^^^^^ help: convert the identifier to upper case: `H_DOMAIN_SIZE`

warning: constant `m_domain_size` should have an upper case name
    --> src/ramlookup/cq.rs:1519:11
     |
1519 |     const m_domain_size: usize = 10;
     |           ^^^^^^^^^^^^^ help: convert the identifier to upper case: `M_DOMAIN_SIZE`

warning: constant `k_domain_size` should have an upper case name
    --> src/ramlookup/cq.rs:1520:11
     |
1520 |     const k_domain_size: usize = 0;
     |           ^^^^^^^^^^^^^ help: convert the identifier to upper case: `K_DOMAIN_SIZE`

warning: variable `N` should have a snake case name
    --> src/ramlookup/cq.rs:1550:13
     |
1550 |         let N: usize = 1usize << h;
     |             ^ help: convert the identifier to snake case: `n`

warning: variable `N` should have a snake case name
    --> src/ramlookup/cq.rs:1583:17
     |
1583 |             let N = 1usize << h_domain_sizes[i];
     |                 ^ help: convert the identifier to snake case: `n`

warning: variable `N` should have a snake case name
    --> src/ramlookup/cq.rs:1641:17
     |
1641 |             let N: usize = 1usize << h_domain_sizes[i];
     |                 ^ help: convert the identifier to snake case: `n`

warning: variable `N` should have a snake case name
    --> src/ramlookup/cq.rs:1964:13
     |
1964 |         let N: usize = 1usize << _h_domain_size;
     |             ^ help: convert the identifier to snake case: `n`

warning: variable `K` should have a snake case name
    --> src/ramlookup/cq.rs:2055:21
     |
2055 |             let mut K = 1usize << log_k;
     |                     ^ help: convert the identifier to snake case (notice the capitalization): `k`

warning: variable `N` should have a snake case name
    --> src/ramlookup/cq.rs:2130:13
     |
2130 |         let N = 1usize << h_domain_size;
     |             ^ help: convert the identifier to snake case: `n`

warning: variable `N` should have a snake case name
    --> src/ramlookup/cq.rs:2184:13
     |
2184 |         let N: usize = 1 << h_domain_size;
     |             ^ help: convert the identifier to snake case: `n`

warning: variable `N_inv` should have a snake case name
    --> src/ramlookup/cq.rs:2226:17
     |
2226 |             let N_inv = E::Fr::from(N as u128).inverse().unwrap();
     |                 ^^^^^ help: convert the identifier to snake case: `n_inv`

warning: variable `N` should have a snake case name
    --> src/ramlookup/cq.rs:2241:13
     |
2241 |         let N: usize = 1 << h_domain_size;
     |             ^ help: convert the identifier to snake case: `n`

warning: variable `N` should have a snake case name
    --> src/ramlookup/mod.rs:1132:13
     |
1132 |         let N: usize = 1 << h_domain_size;
     |             ^ help: convert the identifier to snake case: `n`

warning: `caulk` (lib test) generated 231 warnings (run `cargo fix --lib -p caulk --tests` to apply 72 suggestions)
    Finished `release` profile [optimized] target(s) in 7.79s
     Running unittests src/lib.rs (target/release/deps/caulk-5761a1506561317d)

running 1 test
Running setup for table size 1048576 and batch size 1024
test ramlookup::cq::tests::test_delta_lookup has been running for over 60 seconds
time to setup powers = 91.649209682s
dummy pp setup takes 93 seconds
dummy table init takes 0 seconds
Time to generate example for delta = 1024 is 0 secs
Time to commit t_com (excluded from lookup time) in 26ms
Committed f_com in 33ms
Using update = true
Time for divisions = 0
Computed update params in 0 secs
Time for sub-products = 0
Time for divisions = 0
Computed oracles on set I in 0 secs
Interpolated q polynomial in 0 secs
Time for sub-products = 0
Time for divisions = 0
Evaluated q_dvt on I in 0 secs
Computing b_vec over I took 199 msec
Time for divisions = 0
Computed update params in 0 secs
Time for sub-products = 0
Time for divisions = 0
Computed oracles on set I in 0 secs
Interpolated q polynomial in 0 secs
Time for sub-products = 0
Time for divisions = 0
Evaluated q_dvt on I in 0 secs
Computing a_vec over K took 381 msec
Time taken: 0
Time for sub-products = 0
Time for divisions = 0
Evaluating Z_I'(X) over I took 54 msec
Time for divisions = 0
Evaluating Z_I(X) over K took 53 msec
Time taken: 0
Time for sub-products = 0
Time for divisions = 0
Interpolating C(X) took 102 msec
Time for divisions = 0
Evaluating C(X) over K took 109 msec
Scalar computation took 1027 msec
MSM took 48 msecs
Proof Generation Time for table=1048576 and batch=1024 and delta=1024: 1.280192408 secs
===> Average (finish at delta=1024) lookup time (without table init time) for table=1048576 and batch=1024 is 1.280192408 secs
Time to generate example for delta = 2048 is 0 secs
Time to commit t_com (excluded from lookup time) in 45ms
Committed f_com in 32ms
Using update = true
Time for divisions = 0
Computed update params in 0 secs
Time for sub-products = 0
Time for divisions = 0
Computed oracles on set I in 0 secs
Interpolated q polynomial in 0 secs
Time for sub-products = 0
Time for divisions = 0
Evaluated q_dvt on I in 0 secs
Computing b_vec over I took 198 msec
Time for divisions = 0
Computed update params in 0 secs
Time for sub-products = 0
Time for divisions = 0
Computed oracles on set I in 0 secs
Interpolated q polynomial in 0 secs
Time for sub-products = 0
Time for divisions = 0
Evaluated q_dvt on I in 0 secs
Computing a_vec over K took 714 msec
Time taken: 0
Time for sub-products = 0
Time for divisions = 0
Evaluating Z_I'(X) over I took 52 msec
Time for divisions = 0
Evaluating Z_I(X) over K took 150 msec
Time taken: 0
Time for sub-products = 0
Time for divisions = 0
Interpolating C(X) took 101 msec
Time for divisions = 0
Evaluating C(X) over K took 258 msec
Scalar computation took 1676 msec
MSM took 66 msecs
Proof Generation Time for table=1048576 and batch=1024 and delta=2048: 1.953179775 secs
===> Average (finish at delta=2048) lookup time (without table init time) for table=1048576 and batch=1024 is 1.6166860915 secs
Time to generate example for delta = 4096 is 0 secs
Time to commit t_com (excluded from lookup time) in 86ms
Committed f_com in 32ms
Using update = true
Time for divisions = 0
Computed update params in 0 secs
Time for sub-products = 0
Time for divisions = 0
Computed oracles on set I in 0 secs
Interpolated q polynomial in 0 secs
Time for sub-products = 0
Time for divisions = 0
Evaluated q_dvt on I in 0 secs
Computing b_vec over I took 200 msec
Time for divisions = 0
Computed update params in 0 secs
Time for sub-products = 0
Time for divisions = 0
Computed oracles on set I in 0 secs
Interpolated q polynomial in 0 secs
Time for sub-products = 0
Time for divisions = 0
Evaluated q_dvt on I in 0 secs
Computing a_vec over K took 1473 msec
Time taken: 0
Time for sub-products = 0
Time for divisions = 0
Evaluating Z_I'(X) over I took 52 msec
Time for divisions = 0
Evaluating Z_I(X) over K took 346 msec
Time taken: 0
Time for sub-products = 0
Time for divisions = 0
Interpolating C(X) took 104 msec
Time for divisions = 0
Evaluating C(X) over K took 560 msec
Scalar computation took 3093 msec
MSM took 122 msecs
Proof Generation Time for table=1048576 and batch=1024 and delta=4096: 3.428865042 secs
===> Average (finish at delta=4096) lookup time (without table init time) for table=1048576 and batch=1024 is 2.2638928595357144 secs
Time to generate example for delta = 8192 is 0 secs
Time to commit t_com (excluded from lookup time) in 149ms
Committed f_com in 33ms
Using update = true
Time for divisions = 0
Computed update params in 0 secs
Time for sub-products = 0
Time for divisions = 0
Computed oracles on set I in 0 secs
Interpolated q polynomial in 0 secs
Time for sub-products = 0
Time for divisions = 0
Evaluated q_dvt on I in 0 secs
Computing b_vec over I took 207 msec
Time for divisions = 1
Computed update params in 1 secs
Time for sub-products = 0
Time for divisions = 0
Computed oracles on set I in 0 secs
Interpolated q polynomial in 0 secs
Time for sub-products = 0
Time for divisions = 0
Evaluated q_dvt on I in 0 secs
Computing a_vec over K took 3226 msec
Time taken: 0
Time for sub-products = 0
Time for divisions = 0
Evaluating Z_I'(X) over I took 54 msec
Time for divisions = 0
Evaluating Z_I(X) over K took 758 msec
Time taken: 0
Time for sub-products = 0
Time for divisions = 0
Interpolating C(X) took 109 msec
Time for divisions = 1
Evaluating C(X) over K took 1190 msec
Scalar computation took 6220 msec
MSM took 224 msecs
Proof Generation Time for table=1048576 and batch=1024 and delta=8192: 6.674287086 secs
===> Average (finish at delta=8192) lookup time (without table init time) for table=1048576 and batch=1024 is 3.5417066537124997 secs
Time to generate example for delta = 16384 is 0 secs
Time to commit t_com (excluded from lookup time) in 252ms
Committed f_com in 32ms
Using update = true
Time for divisions = 0
Computed update params in 0 secs
Time for sub-products = 0
Time for divisions = 0
Computed oracles on set I in 0 secs
Interpolated q polynomial in 0 secs
Time for sub-products = 0
Time for divisions = 0
Evaluated q_dvt on I in 0 secs
Computing b_vec over I took 212 msec
Time for divisions = 3
Computed update params in 4 secs
Time for sub-products = 0
Time for divisions = 0
Computed oracles on set I in 0 secs
Interpolated q polynomial in 1 secs
Time for sub-products = 0
Time for divisions = 0
Evaluated q_dvt on I in 0 secs
Computing a_vec over K took 6928 msec
Time taken: 0
Time for sub-products = 0
Time for divisions = 0
Evaluating Z_I'(X) over I took 52 msec
Time for divisions = 1
Evaluating Z_I(X) over K took 1523 msec
Time taken: 0
Time for sub-products = 0
Time for divisions = 0
Interpolating C(X) took 111 msec
Time for divisions = 2
Evaluating C(X) over K took 2460 msec
Scalar computation took 12625 msec
MSM took 427 msecs
Proof Generation Time for table=1048576 and batch=1024 and delta=16384: 13.306531276 secs
===> Average (finish at delta=16384) lookup time (without table init time) for table=1048576 and batch=1024 is 6.002286076159525 secs
Time to generate example for delta = 32768 is 0 secs
Time to commit t_com (excluded from lookup time) in 498ms
Committed f_com in 32ms
Using update = true
Time for divisions = 0
Computed update params in 0 secs
Time for sub-products = 0
Time for divisions = 0
Computed oracles on set I in 0 secs
Interpolated q polynomial in 0 secs
Time for sub-products = 0
Time for divisions = 0
Evaluated q_dvt on I in 0 secs
Computing b_vec over I took 208 msec
Time for divisions = 7
Computed update params in 9 secs
Time for sub-products = 0
Time for divisions = 1
Computed oracles on set I in 1 secs
Interpolated q polynomial in 2 secs
Time for sub-products = 0
Time for divisions = 1
Evaluated q_dvt on I in 1 secs
Computing a_vec over K took 15053 msec
Time taken: 0
Time for sub-products = 0
Time for divisions = 0
Evaluating Z_I'(X) over I took 52 msec
Time for divisions = 3
Evaluating Z_I(X) over K took 3090 msec
Time taken: 0
Time for sub-products = 0
Time for divisions = 0
Interpolating C(X) took 112 msec
Time for divisions = 4
Evaluating C(X) over K took 4756 msec
Scalar computation took 25784 msec
MSM took 632 msecs
Proof Generation Time for table=1048576 and batch=1024 and delta=32768: 26.695404492 secs
===> Average (finish at delta=32768) lookup time (without table init time) for table=1048576 and batch=1024 is 10.759924849631062 secs
Time to generate example for delta = 65536 is 0 secs
Time to commit t_com (excluded from lookup time) in 846ms
Committed f_com in 32ms
Using update = true
Time for divisions = 0
Computed update params in 0 secs
Time for sub-products = 0
Time for divisions = 0
Computed oracles on set I in 0 secs
Interpolated q polynomial in 0 secs
Time for sub-products = 0
Time for divisions = 0
Evaluated q_dvt on I in 0 secs
Computing b_vec over I took 209 msec
Time for divisions = 16
Computed update params in 20 secs
Time for sub-products = 0
Time for divisions = 2
Computed oracles on set I in 3 secs
Interpolated q polynomial in 5 secs
Time for sub-products = 0
Time for divisions = 2
Evaluated q_dvt on I in 2 secs
Computing a_vec over K took 33358 msec
Time taken: 0
Time for sub-products = 0
Time for divisions = 0
Evaluating Z_I'(X) over I took 52 msec
Time for divisions = 6
Evaluating Z_I(X) over K took 6232 msec
Time taken: 0
Time for sub-products = 0
Time for divisions = 0
Interpolating C(X) took 115 msec
Time for divisions = 9
Evaluating C(X) over K took 9600 msec
Scalar computation took 54746 msec
MSM took 1229 msecs
Proof Generation Time for table=1048576 and batch=1024 and delta=65536: 56.322615967 secs
===> Average (finish at delta=65536) lookup time (without table init time) for table=1048576 and batch=1024 is 20.753503542334247 secs
Time to generate example for delta = 131072 is 0 secs
Time to commit t_com (excluded from lookup time) in 1576ms
Committed f_com in 33ms
Using update = true
Time for divisions = 0
Computed update params in 0 secs
Time for sub-products = 0
Time for divisions = 0
Computed oracles on set I in 0 secs
Interpolated q polynomial in 0 secs
Time for sub-products = 0
Time for divisions = 0
Evaluated q_dvt on I in 0 secs
Computing b_vec over I took 221 msec
Time for divisions = 37
Computed update params in 48 secs
Time for sub-products = 0
Time for divisions = 5
Computed oracles on set I in 6 secs
Interpolated q polynomial in 12 secs
Time for sub-products = 0
Time for divisions = 5
Evaluated q_dvt on I in 5 secs
Computing a_vec over K took 74458 msec
Time taken: 0
Time for sub-products = 0
Time for divisions = 0
Evaluating Z_I'(X) over I took 55 msec
Time for divisions = 12
Evaluating Z_I(X) over K took 12898 msec
Time taken: 0
Time for sub-products = 0
Time for divisions = 0
Interpolating C(X) took 123 msec
Time for divisions = 19
Evaluating C(X) over K took 19598 msec
Scalar computation took 117424 msec
MSM took 2221 msecs
Proof Generation Time for table=1048576 and batch=1024 and delta=131072: 120.124389737 secs
===> Average (finish at delta=131072) lookup time (without table init time) for table=1048576 and batch=1024 is 41.930511412313216 secs
Time to generate example for delta = 262144 is 0 secs
Time to commit t_com (excluded from lookup time) in 3110ms
Committed f_com in 32ms
Using update = true
Time for divisions = 0
Computed update params in 0 secs
Time for sub-products = 0
Time for divisions = 0
Computed oracles on set I in 0 secs
Interpolated q polynomial in 0 secs
Time for sub-products = 0
Time for divisions = 0
Evaluated q_dvt on I in 0 secs
Computing b_vec over I took 221 msec
Time for divisions = 85
Computed update params in 106 secs
Time for sub-products = 0
Time for divisions = 11
Computed oracles on set I in 15 secs
Interpolated q polynomial in 28 secs
Time for sub-products = 0
Time for divisions = 11
Evaluated q_dvt on I in 11 secs
Computing a_vec over K took 164917 msec
Time taken: 0
Time for sub-products = 0
Time for divisions = 0
Evaluating Z_I'(X) over I took 52 msec
Time for divisions = 25
Evaluating Z_I(X) over K took 25323 msec
Time taken: 0
Time for sub-products = 0
Time for divisions = 0
Interpolating C(X) took 123 msec
Time for divisions = 39
Evaluating C(X) over K took 39780 msec
Scalar computation took 250219 msec
MSM took 3955 msecs
Proof Generation Time for table=1048576 and batch=1024 and delta=262144: 254.986707363 secs
===> Average (finish at delta=262144) lookup time (without table init time) for table=1048576 and batch=1024 is 86.4822729186623 secs
Time to generate example for delta = 524288 is 1 secs
Time to commit t_com (excluded from lookup time) in 6547ms
Committed f_com in 32ms
Using update = true
Time for divisions = 0
Computed update params in 0 secs
Time for sub-products = 0
Time for divisions = 0
Computed oracles on set I in 0 secs
Interpolated q polynomial in 0 secs
Time for sub-products = 0
Time for divisions = 0
Evaluated q_dvt on I in 0 secs
Computing b_vec over I took 224 msec
Time for divisions = 190
Computed update params in 238 secs
Time for sub-products = 0
Time for divisions = 20
Computed oracles on set I in 24 secs
Interpolated q polynomial in 59 secs
Time for sub-products = 0
Time for divisions = 25
Evaluated q_dvt on I in 25 secs
Computing a_vec over K took 350561 msec
Time taken: 0
Time for sub-products = 0
Time for divisions = 0
Evaluating Z_I'(X) over I took 54 msec
Time for divisions = 51
Evaluating Z_I(X) over K took 51214 msec
Time taken: 0
Time for sub-products = 0
Time for divisions = 0
Interpolating C(X) took 136 msec
Time for divisions = 78
Evaluating C(X) over K took 78741 msec
Scalar computation took 520494 msec
MSM took 7344 msecs
Proof Generation Time for table=1048576 and batch=1024 and delta=524288: 529.081229471 secs
===> Average (finish at delta=524288) lookup time (without table init time) for table=1048576 and batch=1024 is 177.53874407427958 secs
===> Average (finish at delta=table) lookup time (without table init time) for table=1048576 and batch=1024 is 177.53874407427958 secs
Running setup for table size 1048576 and batch size 256
time to setup powers = 90.982427404s
dummy pp setup takes 92 seconds
dummy table init takes 0 seconds
Time to generate example for delta = 256 is 0 secs
Time to commit t_com (excluded from lookup time) in 9ms
Committed f_com in 0ms
Using update = true
Time for divisions = 0
Computed update params in 0 secs
Time for sub-products = 0
Time for divisions = 0
Computed oracles on set I in 0 secs
Interpolated q polynomial in 0 secs
Time for sub-products = 0
Time for divisions = 0
Evaluated q_dvt on I in 0 secs
Computing b_vec over I took 33 msec
Time for divisions = 0
Computed update params in 0 secs
Time for sub-products = 0
Time for divisions = 0
Computed oracles on set I in 0 secs
Interpolated q polynomial in 0 secs
Time for sub-products = 0
Time for divisions = 0
Evaluated q_dvt on I in 0 secs
Computing a_vec over K took 64 msec
Time taken: 0
Time for sub-products = 0
Time for divisions = 0
Evaluating Z_I'(X) over I took 7 msec
Time for divisions = 0
Evaluating Z_I(X) over K took 3 msec
Time taken: 0
Time for sub-products = 0
Time for divisions = 0
Interpolating C(X) took 17 msec
Time for divisions = 0
Evaluating C(X) over K took 5 msec
Scalar computation took 144 msec
MSM took 14 msecs
Proof Generation Time for table=1048576 and batch=256 and delta=256: 0.17106503 secs
===> Average (finish at delta=256) lookup time (without table init time) for table=1048576 and batch=256 is 0.17106503 secs
Time to generate example for delta = 512 is 0 secs
Time to commit t_com (excluded from lookup time) in 16ms
Committed f_com in 0ms
Using update = true
Time for divisions = 0
Computed update params in 0 secs
Time for sub-products = 0
Time for divisions = 0
Computed oracles on set I in 0 secs
Interpolated q polynomial in 0 secs
Time for sub-products = 0
Time for divisions = 0
Evaluated q_dvt on I in 0 secs
Computing b_vec over I took 33 msec
Time for divisions = 0
Computed update params in 0 secs
Time for sub-products = 0
Time for divisions = 0
Computed oracles on set I in 0 secs
Interpolated q polynomial in 0 secs
Time for sub-products = 0
Time for divisions = 0
Evaluated q_dvt on I in 0 secs
Computing a_vec over K took 135 msec
Time taken: 0
Time for sub-products = 0
Time for divisions = 0
Evaluating Z_I'(X) over I took 7 msec
Time for divisions = 0
Evaluating Z_I(X) over K took 11 msec
Time taken: 0
Time for sub-products = 0
Time for divisions = 0
Interpolating C(X) took 17 msec
Time for divisions = 0
Evaluating C(X) over K took 13 msec
Scalar computation took 238 msec
MSM took 26 msecs
Proof Generation Time for table=1048576 and batch=256 and delta=512: 0.277220171 secs
===> Average (finish at delta=512) lookup time (without table init time) for table=1048576 and batch=256 is 0.2241426005 secs
Time to generate example for delta = 1024 is 0 secs
Time to commit t_com (excluded from lookup time) in 25ms
Committed f_com in 0ms
Using update = true
Time for divisions = 0
Computed update params in 0 secs
Time for sub-products = 0
Time for divisions = 0
Computed oracles on set I in 0 secs
Interpolated q polynomial in 0 secs
Time for sub-products = 0
Time for divisions = 0
Evaluated q_dvt on I in 0 secs
Computing b_vec over I took 33 msec
Time for divisions = 0
Computed update params in 0 secs
Time for sub-products = 0
Time for divisions = 0
Computed oracles on set I in 0 secs
Interpolated q polynomial in 0 secs
Time for sub-products = 0
Time for divisions = 0
Evaluated q_dvt on I in 0 secs
Computing a_vec over K took 284 msec
Time taken: 0
Time for sub-products = 0
Time for divisions = 0
Evaluating Z_I'(X) over I took 7 msec
Time for divisions = 0
Evaluating Z_I(X) over K took 27 msec
Time taken: 0
Time for sub-products = 0
Time for divisions = 0
Interpolating C(X) took 17 msec
Time for divisions = 0
Evaluating C(X) over K took 28 msec
Scalar computation took 433 msec
MSM took 47 msecs
Proof Generation Time for table=1048576 and batch=256 and delta=1024: 0.494181917 secs
===> Average (finish at delta=1024) lookup time (without table init time) for table=1048576 and batch=256 is 0.32058521353571434 secs
Time to generate example for delta = 2048 is 0 secs
Time to commit t_com (excluded from lookup time) in 45ms
Committed f_com in 12ms
Using update = true
Time for divisions = 0
Computed update params in 0 secs
Time for sub-products = 0
Time for divisions = 0
Computed oracles on set I in 0 secs
Interpolated q polynomial in 0 secs
Time for sub-products = 0
Time for divisions = 0
Evaluated q_dvt on I in 0 secs
Computing b_vec over I took 33 msec
Time for divisions = 0
Computed update params in 0 secs
Time for sub-products = 0
Time for divisions = 0
Computed oracles on set I in 0 secs
Interpolated q polynomial in 0 secs
Time for sub-products = 0
Time for divisions = 0
Evaluated q_dvt on I in 0 secs
Computing a_vec over K took 623 msec
Time taken: 0
Time for sub-products = 0
Time for divisions = 0
Evaluating Z_I'(X) over I took 7 msec
Time for divisions = 0
Evaluating Z_I(X) over K took 57 msec
Time taken: 0
Time for sub-products = 0
Time for divisions = 0
Interpolating C(X) took 18 msec
Time for divisions = 0
Evaluating C(X) over K took 59 msec
Scalar computation took 864 msec
MSM took 66 msecs
Proof Generation Time for table=1048576 and batch=256 and delta=2048: 1.012982592 secs
===> Average (finish at delta=2048) lookup time (without table init time) for table=1048576 and batch=256 is 0.5215534441625 secs
Time to generate example for delta = 4096 is 0 secs
Time to commit t_com (excluded from lookup time) in 86ms
Committed f_com in 0ms
Using update = true
Time for divisions = 0
Computed update params in 0 secs
Time for sub-products = 0
Time for divisions = 0
Computed oracles on set I in 0 secs
Interpolated q polynomial in 0 secs
Time for sub-products = 0
Time for divisions = 0
Evaluated q_dvt on I in 0 secs
Computing b_vec over I took 33 msec
Time for divisions = 0
Computed update params in 0 secs
Time for sub-products = 0
Time for divisions = 0
Computed oracles on set I in 0 secs
Interpolated q polynomial in 0 secs
Time for sub-products = 0
Time for divisions = 0
Evaluated q_dvt on I in 0 secs
Computing a_vec over K took 1375 msec
Time taken: 0
Time for sub-products = 0
Time for divisions = 0
Evaluating Z_I'(X) over I took 7 msec
Time for divisions = 0
Evaluating Z_I(X) over K took 120 msec
Time taken: 0
Time for sub-products = 0
Time for divisions = 0
Interpolating C(X) took 17 msec
Time for divisions = 0
Evaluating C(X) over K took 121 msec
Scalar computation took 1798 msec
MSM took 122 msecs
Proof Generation Time for table=1048576 and batch=256 and delta=4096: 1.938958662 secs
===> Average (finish at delta=4096) lookup time (without table init time) for table=1048576 and batch=256 is 0.8763900173823085 secs
Time to generate example for delta = 8192 is 0 secs
Time to commit t_com (excluded from lookup time) in 145ms
Committed f_com in 11ms
Using update = true
Time for divisions = 0
Computed update params in 0 secs
Time for sub-products = 0
Time for divisions = 0
Computed oracles on set I in 0 secs
Interpolated q polynomial in 0 secs
Time for sub-products = 0
Time for divisions = 0
Evaluated q_dvt on I in 0 secs
Computing b_vec over I took 34 msec
Time for divisions = 1
Computed update params in 1 secs
Time for sub-products = 0
Time for divisions = 0
Computed oracles on set I in 0 secs
Interpolated q polynomial in 0 secs
Time for sub-products = 0
Time for divisions = 0
Evaluated q_dvt on I in 0 secs
Computing a_vec over K took 3072 msec
Time taken: 0
Time for sub-products = 0
Time for divisions = 0
Evaluating Z_I'(X) over I took 8 msec
Time for divisions = 0
Evaluating Z_I(X) over K took 247 msec
Time taken: 0
Time for sub-products = 0
Time for divisions = 0
Interpolating C(X) took 18 msec
Time for divisions = 0
Evaluating C(X) over K took 244 msec
Scalar computation took 3863 msec
MSM took 225 msecs
Proof Generation Time for table=1048576 and batch=256 and delta=8192: 4.185441117 secs
===> Average (finish at delta=8192) lookup time (without table init time) for table=1048576 and batch=256 is 1.645310129466727 secs
Time to generate example for delta = 16384 is 0 secs
Time to commit t_com (excluded from lookup time) in 251ms
Committed f_com in 12ms
Using update = true
Time for divisions = 0
Computed update params in 0 secs
Time for sub-products = 0
Time for divisions = 0
Computed oracles on set I in 0 secs
Interpolated q polynomial in 0 secs
Time for sub-products = 0
Time for divisions = 0
Evaluated q_dvt on I in 0 secs
Computing b_vec over I took 34 msec
Time for divisions = 3
Computed update params in 4 secs
Time for sub-products = 0
Time for divisions = 0
Computed oracles on set I in 0 secs
Interpolated q polynomial in 1 secs
Time for sub-products = 0
Time for divisions = 0
Evaluated q_dvt on I in 0 secs
Computing a_vec over K took 6755 msec
Time taken: 0
Time for sub-products = 0
Time for divisions = 0
Evaluating Z_I'(X) over I took 7 msec
Time for divisions = 0
Evaluating Z_I(X) over K took 493 msec
Time taken: 0
Time for sub-products = 0
Time for divisions = 0
Interpolating C(X) took 19 msec
Time for divisions = 0
Evaluating C(X) over K took 493 msec
Scalar computation took 8272 msec
MSM took 409 msecs
Proof Generation Time for table=1048576 and batch=256 and delta=16384: 8.795786005 secs
===> Average (finish at delta=16384) lookup time (without table init time) for table=1048576 and batch=256 is 3.2146368652004713 secs
Time to generate example for delta = 32768 is 0 secs
Time to commit t_com (excluded from lookup time) in 499ms
Committed f_com in 12ms
Using update = true
Time for divisions = 0
Computed update params in 0 secs
Time for sub-products = 0
Time for divisions = 0
Computed oracles on set I in 0 secs
Interpolated q polynomial in 0 secs
Time for sub-products = 0
Time for divisions = 0
Evaluated q_dvt on I in 0 secs
Computing b_vec over I took 35 msec
Time for divisions = 7
Computed update params in 9 secs
Time for sub-products = 0
Time for divisions = 1
Computed oracles on set I in 1 secs
Interpolated q polynomial in 2 secs
Time for sub-products = 0
Time for divisions = 1
Evaluated q_dvt on I in 1 secs
Computing a_vec over K took 15622 msec
Time taken: 0
Time for sub-products = 0
Time for divisions = 0
Evaluating Z_I'(X) over I took 8 msec
Time for divisions = 1
Evaluating Z_I(X) over K took 1032 msec
Time taken: 0
Time for sub-products = 0
Time for divisions = 0
Interpolating C(X) took 21 msec
Time for divisions = 1
Evaluating C(X) over K took 1014 msec
Scalar computation took 18674 msec
MSM took 642 msecs
Proof Generation Time for table=1048576 and batch=256 and delta=32768: 19.464904023 secs
===> Average (finish at delta=32768) lookup time (without table init time) for table=1048576 and batch=256 is 6.704556959309346 secs
Time to generate example for delta = 65536 is 0 secs
Time to commit t_com (excluded from lookup time) in 862ms
Committed f_com in 12ms
Using update = true
Time for divisions = 0
Computed update params in 0 secs
Time for sub-products = 0
Time for divisions = 0
Computed oracles on set I in 0 secs
Interpolated q polynomial in 0 secs
Time for sub-products = 0
Time for divisions = 0
Evaluated q_dvt on I in 0 secs
Computing b_vec over I took 35 msec
Time for divisions = 16
Computed update params in 20 secs
Time for sub-products = 0
Time for divisions = 2
Computed oracles on set I in 3 secs
Interpolated q polynomial in 5 secs
Time for sub-products = 0
Time for divisions = 2
Evaluated q_dvt on I in 2 secs
Computing a_vec over K took 33261 msec
Time taken: 0
Time for sub-products = 0
Time for divisions = 0
Evaluating Z_I'(X) over I took 8 msec
Time for divisions = 2
Evaluating Z_I(X) over K took 2045 msec
Time taken: 0
Time for sub-products = 0
Time for divisions = 0
Interpolating C(X) took 20 msec
Time for divisions = 2
Evaluating C(X) over K took 2028 msec
Scalar computation took 39332 msec
MSM took 1264 msecs
Proof Generation Time for table=1048576 and batch=256 and delta=65536: 40.811254545 secs
===> Average (finish at delta=65536) lookup time (without table init time) for table=1048576 and batch=256 is 13.825385605005966 secs
Time to generate example for delta = 131072 is 0 secs
Time to commit t_com (excluded from lookup time) in 1541ms
Committed f_com in 12ms
Using update = true
Time for divisions = 0
Computed update params in 0 secs
Time for sub-products = 0
Time for divisions = 0
Computed oracles on set I in 0 secs
Interpolated q polynomial in 0 secs
Time for sub-products = 0
Time for divisions = 0
Evaluated q_dvt on I in 0 secs
Computing b_vec over I took 36 msec
Time for divisions = 37
Computed update params in 47 secs
Time for sub-products = 0
Time for divisions = 5
Computed oracles on set I in 6 secs
Interpolated q polynomial in 13 secs
Time for sub-products = 0
Time for divisions = 5
Evaluated q_dvt on I in 5 secs
Computing a_vec over K took 74380 msec
Time taken: 0
Time for sub-products = 0
Time for divisions = 0
Evaluating Z_I'(X) over I took 7 msec
Time for divisions = 3
Evaluating Z_I(X) over K took 3995 msec
Time taken: 0
Time for sub-products = 0
Time for divisions = 0
Interpolating C(X) took 22 msec
Time for divisions = 4
Evaluating C(X) over K took 4045 msec
Scalar computation took 86189 msec
MSM took 2226 msecs
Proof Generation Time for table=1048576 and batch=256 and delta=131072: 88.73959899 secs
===> Average (finish at delta=131072) lookup time (without table init time) for table=1048576 and batch=256 is 29.41202863088962 secs
Time to generate example for delta = 262144 is 0 secs
Time to commit t_com (excluded from lookup time) in 3262ms
Committed f_com in 12ms
Using update = true
Time for divisions = 0
Computed update params in 0 secs
Time for sub-products = 0
Time for divisions = 0
Computed oracles on set I in 0 secs
Interpolated q polynomial in 0 secs
Time for sub-products = 0
Time for divisions = 0
Evaluated q_dvt on I in 0 secs
Computing b_vec over I took 39 msec
Time for divisions = 85
Computed update params in 107 secs
Time for sub-products = 0
Time for divisions = 11
Computed oracles on set I in 14 secs
Interpolated q polynomial in 27 secs
Time for sub-products = 0
Time for divisions = 11
Evaluated q_dvt on I in 11 secs
Computing a_vec over K took 165121 msec
Time taken: 0
Time for sub-products = 0
Time for divisions = 0
Evaluating Z_I'(X) over I took 7 msec
Time for divisions = 8
Evaluating Z_I(X) over K took 8148 msec
Time taken: 0
Time for sub-products = 0
Time for divisions = 0
Interpolating C(X) took 23 msec
Time for divisions = 7
Evaluating C(X) over K took 7957 msec
Scalar computation took 188820 msec
MSM took 3754 msecs
Proof Generation Time for table=1048576 and batch=256 and delta=262144: 193.160123488 secs
===> Average (finish at delta=262144) lookup time (without table init time) for table=1048576 and batch=256 is 63.35870149247901 secs
Time to generate example for delta = 524288 is 1 secs
Time to commit t_com (excluded from lookup time) in 6582ms
Committed f_com in 12ms
Using update = true
Time for divisions = 0
Computed update params in 0 secs
Time for sub-products = 0
Time for divisions = 0
Computed oracles on set I in 0 secs
Interpolated q polynomial in 0 secs
Time for sub-products = 0
Time for divisions = 0
Evaluated q_dvt on I in 0 secs
Computing b_vec over I took 41 msec
Time for divisions = 188
Computed update params in 235 secs
Time for sub-products = 0
Time for divisions = 19
Computed oracles on set I in 23 secs
Interpolated q polynomial in 59 secs
Time for sub-products = 0
Time for divisions = 24
Evaluated q_dvt on I in 24 secs
Computing a_vec over K took 346443 msec
Time taken: 0
Time for sub-products = 0
Time for divisions = 0
Evaluating Z_I'(X) over I took 7 msec
Time for divisions = 16
Evaluating Z_I(X) over K took 16438 msec
Time taken: 0
Time for sub-products = 0
Time for divisions = 0
Interpolating C(X) took 24 msec
Time for divisions = 15
Evaluating C(X) over K took 15985 msec
Scalar computation took 393945 msec
MSM took 7498 msecs
Proof Generation Time for table=1048576 and batch=256 and delta=524288: 402.534951197 secs
===> Average (finish at delta=524288) lookup time (without table init time) for table=1048576 and batch=256 is 132.72507305850195 secs
===> Average (finish at delta=table) lookup time (without table init time) for table=1048576 and batch=256 is 132.72507305850195 secs
Running setup for table size 2097152 and batch size 1024
time to setup powers = 167.943104795s
dummy pp setup takes 170 seconds
dummy table init takes 1 seconds
Time to generate example for delta = 1024 is 1 secs
Time to commit t_com (excluded from lookup time) in 25ms
Committed f_com in 0ms
Using update = true
Time for divisions = 0
Computed update params in 0 secs
Time for sub-products = 0
Time for divisions = 0
Computed oracles on set I in 0 secs
Interpolated q polynomial in 0 secs
Time for sub-products = 0
Time for divisions = 0
Evaluated q_dvt on I in 0 secs
Computing b_vec over I took 198 msec
Time for divisions = 0
Computed update params in 0 secs
Time for sub-products = 0
Time for divisions = 0
Computed oracles on set I in 0 secs
Interpolated q polynomial in 0 secs
Time for sub-products = 0
Time for divisions = 0
Evaluated q_dvt on I in 0 secs
Computing a_vec over K took 375 msec
Time taken: 0
Time for sub-products = 0
Time for divisions = 0
Evaluating Z_I'(X) over I took 52 msec
Time for divisions = 0
Evaluating Z_I(X) over K took 52 msec
Time taken: 0
Time for sub-products = 0
Time for divisions = 0
Interpolating C(X) took 98 msec
Time for divisions = 0
Evaluating C(X) over K took 106 msec
Scalar computation took 1007 msec
MSM took 47 msecs
Proof Generation Time for table=2097152 and batch=1024 and delta=1024: 1.081334468 secs
===> Average (finish at delta=1024) lookup time (without table init time) for table=2097152 and batch=1024 is 1.081334468 secs
Time to generate example for delta = 2048 is 1 secs
Time to commit t_com (excluded from lookup time) in 45ms
Committed f_com in 0ms
Using update = true
Time for divisions = 0
Computed update params in 0 secs
Time for sub-products = 0
Time for divisions = 0
Computed oracles on set I in 0 secs
Interpolated q polynomial in 0 secs
Time for sub-products = 0
Time for divisions = 0
Evaluated q_dvt on I in 0 secs
Computing b_vec over I took 194 msec
Time for divisions = 0
Computed update params in 0 secs
Time for sub-products = 0
Time for divisions = 0
Computed oracles on set I in 0 secs
Interpolated q polynomial in 0 secs
Time for sub-products = 0
Time for divisions = 0
Evaluated q_dvt on I in 0 secs
Computing a_vec over K took 703 msec
Time taken: 0
Time for sub-products = 0
Time for divisions = 0
Evaluating Z_I'(X) over I took 52 msec
Time for divisions = 0
Evaluating Z_I(X) over K took 150 msec
Time taken: 0
Time for sub-products = 0
Time for divisions = 0
Interpolating C(X) took 99 msec
Time for divisions = 0
Evaluating C(X) over K took 255 msec
Scalar computation took 1657 msec
MSM took 66 msecs
Proof Generation Time for table=2097152 and batch=1024 and delta=2048: 1.750434185 secs
===> Average (finish at delta=2048) lookup time (without table init time) for table=2097152 and batch=1024 is 1.4158843264999998 secs
Time to generate example for delta = 4096 is 1 secs
Time to commit t_com (excluded from lookup time) in 86ms
Committed f_com in 32ms
Using update = true
Time for divisions = 0
Computed update params in 0 secs
Time for sub-products = 0
Time for divisions = 0
Computed oracles on set I in 0 secs
Interpolated q polynomial in 0 secs
Time for sub-products = 0
Time for divisions = 0
Evaluated q_dvt on I in 0 secs
Computing b_vec over I took 199 msec
Time for divisions = 0
Computed update params in 0 secs
Time for sub-products = 0
Time for divisions = 0
Computed oracles on set I in 0 secs
Interpolated q polynomial in 0 secs
Time for sub-products = 0
Time for divisions = 0
Evaluated q_dvt on I in 0 secs
Computing a_vec over K took 1471 msec
Time taken: 0
Time for sub-products = 0
Time for divisions = 0
Evaluating Z_I'(X) over I took 52 msec
Time for divisions = 0
Evaluating Z_I(X) over K took 345 msec
Time taken: 0
Time for sub-products = 0
Time for divisions = 0
Interpolating C(X) took 103 msec
Time for divisions = 0
Evaluating C(X) over K took 558 msec
Scalar computation took 3086 msec
MSM took 121 msecs
Proof Generation Time for table=2097152 and batch=1024 and delta=4096: 3.419803195 secs
===> Average (finish at delta=4096) lookup time (without table init time) for table=2097152 and batch=1024 is 2.1315696366785715 secs
Time to generate example for delta = 8192 is 1 secs
Time to commit t_com (excluded from lookup time) in 145ms
Committed f_com in 32ms
Using update = true
Time for divisions = 0
Computed update params in 0 secs
Time for sub-products = 0
Time for divisions = 0
Computed oracles on set I in 0 secs
Interpolated q polynomial in 0 secs
Time for sub-products = 0
Time for divisions = 0
Evaluated q_dvt on I in 0 secs
Computing b_vec over I took 200 msec
Time for divisions = 1
Computed update params in 1 secs
Time for sub-products = 0
Time for divisions = 0
Computed oracles on set I in 0 secs
Interpolated q polynomial in 0 secs
Time for sub-products = 0
Time for divisions = 0
Evaluated q_dvt on I in 0 secs
Computing a_vec over K took 3200 msec
Time taken: 0
Time for sub-products = 0
Time for divisions = 0
Evaluating Z_I'(X) over I took 55 msec
Time for divisions = 0
Evaluating Z_I(X) over K took 779 msec
Time taken: 0
Time for sub-products = 0
Time for divisions = 0
Interpolating C(X) took 111 msec
Time for divisions = 1
Evaluating C(X) over K took 1219 msec
Scalar computation took 6252 msec
MSM took 231 msecs
Proof Generation Time for table=2097152 and batch=1024 and delta=8192: 6.711398512 secs
===> Average (finish at delta=8192) lookup time (without table init time) for table=2097152 and batch=1024 is 3.4554203275625004 secs
Time to generate example for delta = 16384 is 1 secs
Time to commit t_com (excluded from lookup time) in 260ms
Committed f_com in 33ms
Using update = true
Time for divisions = 0
Computed update params in 0 secs
Time for sub-products = 0
Time for divisions = 0
Computed oracles on set I in 0 secs
Interpolated q polynomial in 0 secs
Time for sub-products = 0
Time for divisions = 0
Evaluated q_dvt on I in 0 secs
Computing b_vec over I took 202 msec
Time for divisions = 3
Computed update params in 4 secs
Time for sub-products = 0
Time for divisions = 0
Computed oracles on set I in 0 secs
Interpolated q polynomial in 1 secs
Time for sub-products = 0
Time for divisions = 0
Evaluated q_dvt on I in 0 secs
Computing a_vec over K took 6872 msec
Time taken: 0
Time for sub-products = 0
Time for divisions = 0
Evaluating Z_I'(X) over I took 52 msec
Time for divisions = 1
Evaluating Z_I(X) over K took 1522 msec
Time taken: 0
Time for sub-products = 0
Time for divisions = 0
Interpolating C(X) took 106 msec
Time for divisions = 2
Evaluating C(X) over K took 2358 msec
Scalar computation took 12394 msec
MSM took 407 msecs
Proof Generation Time for table=2097152 and batch=1024 and delta=16384: 13.050571111 secs
===> Average (finish at delta=16384) lookup time (without table init time) for table=2097152 and batch=1024 is 5.859113411233115 secs
Time to generate example for delta = 32768 is 1 secs
Time to commit t_com (excluded from lookup time) in 513ms
Committed f_com in 33ms
Using update = true
Time for divisions = 0
Computed update params in 0 secs
Time for sub-products = 0
Time for divisions = 0
Computed oracles on set I in 0 secs
Interpolated q polynomial in 0 secs
Time for sub-products = 0
Time for divisions = 0
Evaluated q_dvt on I in 0 secs
Computing b_vec over I took 211 msec
Time for divisions = 7
Computed update params in 9 secs
Time for sub-products = 0
Time for divisions = 1
Computed oracles on set I in 1 secs
Interpolated q polynomial in 2 secs
Time for sub-products = 0
Time for divisions = 1
Evaluated q_dvt on I in 1 secs
Computing a_vec over K took 15050 msec
Time taken: 0
Time for sub-products = 0
Time for divisions = 0
Evaluating Z_I'(X) over I took 52 msec
Time for divisions = 3
Evaluating Z_I(X) over K took 3119 msec
Time taken: 0
Time for sub-products = 0
Time for divisions = 0
Interpolating C(X) took 116 msec
Time for divisions = 4
Evaluating C(X) over K took 4800 msec
Scalar computation took 25861 msec
MSM took 632 msecs
Proof Generation Time for table=2097152 and batch=1024 and delta=32768: 26.775707889 secs
===> Average (finish at delta=32768) lookup time (without table init time) for table=2097152 and batch=1024 is 10.676788725216355 secs
Time to generate example for delta = 65536 is 1 secs
Time to commit t_com (excluded from lookup time) in 864ms
Committed f_com in 34ms
Using update = true
Time for divisions = 0
Computed update params in 0 secs
Time for sub-products = 0
Time for divisions = 0
Computed oracles on set I in 0 secs
Interpolated q polynomial in 0 secs
Time for sub-products = 0
Time for divisions = 0
Evaluated q_dvt on I in 0 secs
Computing b_vec over I took 219 msec
Time for divisions = 16
Computed update params in 21 secs
Time for sub-products = 0
Time for divisions = 2
Computed oracles on set I in 3 secs
Interpolated q polynomial in 5 secs
Time for sub-products = 0
Time for divisions = 2
Evaluated q_dvt on I in 2 secs
Computing a_vec over K took 33457 msec
Time taken: 0
Time for sub-products = 0
Time for divisions = 0
Evaluating Z_I'(X) over I took 54 msec
Time for divisions = 6
Evaluating Z_I(X) over K took 6390 msec
Time taken: 0
Time for sub-products = 0
Time for divisions = 0
Interpolating C(X) took 115 msec
Time for divisions = 9
Evaluating C(X) over K took 9787 msec
Scalar computation took 55104 msec
MSM took 1230 msecs
Proof Generation Time for table=2097152 and batch=1024 and delta=65536: 56.689948181 secs
===> Average (finish at delta=65536) lookup time (without table init time) for table=2097152 and batch=1024 is 20.77395782096693 secs
Time to generate example for delta = 131072 is 1 secs
Time to commit t_com (excluded from lookup time) in 1557ms
Committed f_com in 32ms
Using update = true
Time for divisions = 0
Computed update params in 0 secs
Time for sub-products = 0
Time for divisions = 0
Computed oracles on set I in 0 secs
Interpolated q polynomial in 0 secs
Time for sub-products = 0
Time for divisions = 0
Evaluated q_dvt on I in 0 secs
Computing b_vec over I took 211 msec
Time for divisions = 37
Computed update params in 47 secs
Time for sub-products = 0
Time for divisions = 5
Computed oracles on set I in 7 secs
Interpolated q polynomial in 13 secs
Time for sub-products = 0
Time for divisions = 5
Evaluated q_dvt on I in 5 secs
Computing a_vec over K took 74530 msec
Time taken: 0
Time for sub-products = 0
Time for divisions = 0
Evaluating Z_I'(X) over I took 52 msec
Time for divisions = 12
Evaluating Z_I(X) over K took 12952 msec
Time taken: 0
Time for sub-products = 0
Time for divisions = 0
Interpolating C(X) took 115 msec
Time for divisions = 19
Evaluating C(X) over K took 19404 msec
Scalar computation took 117583 msec
MSM took 2222 msecs
Proof Generation Time for table=2097152 and batch=1024 and delta=131072: 120.274301784 secs
===> Average (finish at delta=131072) lookup time (without table init time) for table=2097152 and batch=1024 is 41.94811744053351 secs
Time to generate example for delta = 262144 is 1 secs
Time to commit t_com (excluded from lookup time) in 3214ms
Committed f_com in 34ms
Using update = true
Time for divisions = 0
Computed update params in 0 secs
Time for sub-products = 0
Time for divisions = 0
Computed oracles on set I in 0 secs
Interpolated q polynomial in 0 secs
Time for sub-products = 0
Time for divisions = 0
Evaluated q_dvt on I in 0 secs
Computing b_vec over I took 227 msec
Time for divisions = 85
Computed update params in 107 secs
Time for sub-products = 0
Time for divisions = 11
Computed oracles on set I in 14 secs
Interpolated q polynomial in 27 secs
Time for sub-products = 0
Time for divisions = 11
Evaluated q_dvt on I in 11 secs
Computing a_vec over K took 164636 msec
Time taken: 0
Time for sub-products = 0
Time for divisions = 0
Evaluating Z_I'(X) over I took 52 msec
Time for divisions = 25
Evaluating Z_I(X) over K took 25617 msec
Time taken: 0
Time for sub-products = 0
Time for divisions = 0
Interpolating C(X) took 122 msec
Time for divisions = 39
Evaluating C(X) over K took 39171 msec
Scalar computation took 249752 msec
MSM took 3972 msecs
Proof Generation Time for table=2097152 and batch=1024 and delta=262144: 254.488556603 secs
===> Average (finish at delta=262144) lookup time (without table init time) for table=2097152 and batch=1024 is 86.33576075845393 secs
Time to generate example for delta = 524288 is 1 secs
Time to commit t_com (excluded from lookup time) in 6260ms
Committed f_com in 32ms
Using update = true
Time for divisions = 0
Computed update params in 0 secs
Time for sub-products = 0
Time for divisions = 0
Computed oracles on set I in 0 secs
Interpolated q polynomial in 0 secs
Time for sub-products = 0
Time for divisions = 0
Evaluated q_dvt on I in 0 secs
Computing b_vec over I took 218 msec
Time for divisions = 192
Computed update params in 239 secs
Time for sub-products = 0
Time for divisions = 25
Computed oracles on set I in 32 secs
Interpolated q polynomial in 59 secs
Time for sub-products = 0
Time for divisions = 25
Evaluated q_dvt on I in 25 secs
Computing a_vec over K took 362984 msec
Time taken: 0
Time for sub-products = 0
Time for divisions = 0
Evaluating Z_I'(X) over I took 52 msec
Time for divisions = 51
Evaluating Z_I(X) over K took 51482 msec
Time taken: 0
Time for sub-products = 0
Time for divisions = 0
Interpolating C(X) took 122 msec
Time for divisions = 77
Evaluating C(X) over K took 78055 msec
Scalar computation took 532727 msec
MSM took 7550 msecs
Proof Generation Time for table=2097152 and batch=1024 and delta=524288: 541.548152496 secs
===> Average (finish at delta=524288) lookup time (without table init time) for table=2097152 and batch=1024 is 180.5610031635881 secs
Time to generate example for delta = 1048576 is 4 secs
Time to commit t_com (excluded from lookup time) in 12090ms
Committed f_com in 33ms
Using update = true
Time for divisions = 0
Computed update params in 0 secs
Time for sub-products = 0
Time for divisions = 0
Computed oracles on set I in 0 secs
Interpolated q polynomial in 0 secs
Time for sub-products = 0
Time for divisions = 0
Evaluated q_dvt on I in 0 secs
Computing b_vec over I took 230 msec
Time for divisions = 425
Computed update params in 527 secs
Time for sub-products = 0
Time for divisions = 43
Computed oracles on set I in 50 secs
Interpolated q polynomial in 128 secs
Time for sub-products = 0
Time for divisions = 53
Evaluated q_dvt on I in 53 secs
Computing a_vec over K took 766678 msec
Time taken: 0
Time for sub-products = 0
Time for divisions = 0
Evaluating Z_I'(X) over I took 53 msec
Time for divisions = 101
Evaluating Z_I(X) over K took 101854 msec
Time taken: 0
Time for sub-products = 0
Time for divisions = 0
Interpolating C(X) took 134 msec
Time for divisions = 157
Evaluating C(X) over K took 157441 msec
Scalar computation took 1107088 msec
MSM took 14397 msecs
Proof Generation Time for table=2097152 and batch=1024 and delta=1048576: 1123.942197931 secs
===> Average (finish at delta=1048576) lookup time (without table init time) for table=2097152 and batch=1024 is 373.5468810160984 secs
===> Average (finish at delta=table) lookup time (without table init time) for table=2097152 and batch=1024 is 373.5468810160984 secs
Running setup for table size 2097152 and batch size 256
time to setup powers = 168.044054926s
dummy pp setup takes 171 seconds
dummy table init takes 1 seconds
Time to generate example for delta = 256 is 1 secs
Time to commit t_com (excluded from lookup time) in 9ms
Committed f_com in 0ms
Using update = true
Time for divisions = 0
Computed update params in 0 secs
Time for sub-products = 0
Time for divisions = 0
Computed oracles on set I in 0 secs
Interpolated q polynomial in 0 secs
Time for sub-products = 0
Time for divisions = 0
Evaluated q_dvt on I in 0 secs
Computing b_vec over I took 33 msec
Time for divisions = 0
Computed update params in 0 secs
Time for sub-products = 0
Time for divisions = 0
Computed oracles on set I in 0 secs
Interpolated q polynomial in 0 secs
Time for sub-products = 0
Time for divisions = 0
Evaluated q_dvt on I in 0 secs
Computing a_vec over K took 64 msec
Time taken: 0
Time for sub-products = 0
Time for divisions = 0
Evaluating Z_I'(X) over I took 7 msec
Time for divisions = 0
Evaluating Z_I(X) over K took 3 msec
Time taken: 0
Time for sub-products = 0
Time for divisions = 0
Interpolating C(X) took 17 msec
Time for divisions = 0
Evaluating C(X) over K took 5 msec
Scalar computation took 144 msec
MSM took 14 msecs
Proof Generation Time for table=2097152 and batch=256 and delta=256: 0.170670046 secs
===> Average (finish at delta=256) lookup time (without table init time) for table=2097152 and batch=256 is 0.170670046 secs
Time to generate example for delta = 512 is 1 secs
Time to commit t_com (excluded from lookup time) in 18ms
Committed f_com in 0ms
Using update = true
Time for divisions = 0
Computed update params in 0 secs
Time for sub-products = 0
Time for divisions = 0
Computed oracles on set I in 0 secs
Interpolated q polynomial in 0 secs
Time for sub-products = 0
Time for divisions = 0
Evaluated q_dvt on I in 0 secs
Computing b_vec over I took 35 msec
Time for divisions = 0
Computed update params in 0 secs
Time for sub-products = 0
Time for divisions = 0
Computed oracles on set I in 0 secs
Interpolated q polynomial in 0 secs
Time for sub-products = 0
Time for divisions = 0
Evaluated q_dvt on I in 0 secs
Computing a_vec over K took 143 msec
Time taken: 0
Time for sub-products = 0
Time for divisions = 0
Evaluating Z_I'(X) over I took 8 msec
Time for divisions = 0
Evaluating Z_I(X) over K took 12 msec
Time taken: 0
Time for sub-products = 0
Time for divisions = 0
Interpolating C(X) took 18 msec
Time for divisions = 0
Evaluating C(X) over K took 13 msec
Scalar computation took 253 msec
MSM took 27 msecs
Proof Generation Time for table=2097152 and batch=256 and delta=512: 0.293213712 secs
===> Average (finish at delta=512) lookup time (without table init time) for table=2097152 and batch=256 is 0.231941879 secs
Time to generate example for delta = 1024 is 1 secs
Time to commit t_com (excluded from lookup time) in 27ms
Committed f_com in 0ms
Using update = true
Time for divisions = 0
Computed update params in 0 secs
Time for sub-products = 0
Time for divisions = 0
Computed oracles on set I in 0 secs
Interpolated q polynomial in 0 secs
Time for sub-products = 0
Time for divisions = 0
Evaluated q_dvt on I in 0 secs
Computing b_vec over I took 35 msec
Time for divisions = 0
Computed update params in 0 secs
Time for sub-products = 0
Time for divisions = 0
Computed oracles on set I in 0 secs
Interpolated q polynomial in 0 secs
Time for sub-products = 0
Time for divisions = 0
Evaluated q_dvt on I in 0 secs
Computing a_vec over K took 292 msec
Time taken: 0
Time for sub-products = 0
Time for divisions = 0
Evaluating Z_I'(X) over I took 7 msec
Time for divisions = 0
Evaluating Z_I(X) over K took 27 msec
Time taken: 0
Time for sub-products = 0
Time for divisions = 0
Interpolating C(X) took 17 msec
Time for divisions = 0
Evaluating C(X) over K took 28 msec
Scalar computation took 443 msec
MSM took 47 msecs
Proof Generation Time for table=2097152 and batch=256 and delta=1024: 0.504398383 secs
===> Average (finish at delta=1024) lookup time (without table init time) for table=2097152 and batch=256 is 0.32924777328571425 secs
Time to generate example for delta = 2048 is 1 secs
Time to commit t_com (excluded from lookup time) in 45ms
Committed f_com in 12ms
Using update = true
Time for divisions = 0
Computed update params in 0 secs
Time for sub-products = 0
Time for divisions = 0
Computed oracles on set I in 0 secs
Interpolated q polynomial in 0 secs
Time for sub-products = 0
Time for divisions = 0
Evaluated q_dvt on I in 0 secs
Computing b_vec over I took 33 msec
Time for divisions = 0
Computed update params in 0 secs
Time for sub-products = 0
Time for divisions = 0
Computed oracles on set I in 0 secs
Interpolated q polynomial in 0 secs
Time for sub-products = 0
Time for divisions = 0
Evaluated q_dvt on I in 0 secs
Computing a_vec over K took 624 msec
Time taken: 0
Time for sub-products = 0
Time for divisions = 0
Evaluating Z_I'(X) over I took 7 msec
Time for divisions = 0
Evaluating Z_I(X) over K took 58 msec
Time taken: 0
Time for sub-products = 0
Time for divisions = 0
Interpolating C(X) took 18 msec
Time for divisions = 0
Evaluating C(X) over K took 59 msec
Scalar computation took 865 msec
MSM took 66 msecs
Proof Generation Time for table=2097152 and batch=256 and delta=2048: 1.01390255 secs
===> Average (finish at delta=2048) lookup time (without table init time) for table=2097152 and batch=256 is 0.5278327937 secs
Time to generate example for delta = 4096 is 1 secs
Time to commit t_com (excluded from lookup time) in 86ms
Committed f_com in 0ms
Using update = true
Time for divisions = 0
Computed update params in 0 secs
Time for sub-products = 0
Time for divisions = 0
Computed oracles on set I in 0 secs
Interpolated q polynomial in 0 secs
Time for sub-products = 0
Time for divisions = 0
Evaluated q_dvt on I in 0 secs
Computing b_vec over I took 33 msec
Time for divisions = 0
Computed update params in 0 secs
Time for sub-products = 0
Time for divisions = 0
Computed oracles on set I in 0 secs
Interpolated q polynomial in 0 secs
Time for sub-products = 0
Time for divisions = 0
Evaluated q_dvt on I in 0 secs
Computing a_vec over K took 1377 msec
Time taken: 0
Time for sub-products = 0
Time for divisions = 0
Evaluating Z_I'(X) over I took 7 msec
Time for divisions = 0
Evaluating Z_I(X) over K took 119 msec
Time taken: 0
Time for sub-products = 0
Time for divisions = 0
Interpolating C(X) took 17 msec
Time for divisions = 0
Evaluating C(X) over K took 121 msec
Scalar computation took 1799 msec
MSM took 121 msecs
Proof Generation Time for table=2097152 and batch=256 and delta=4096: 1.9403820980000002 secs
===> Average (finish at delta=4096) lookup time (without table init time) for table=2097152 and batch=256 is 0.8816255132883065 secs
Time to generate example for delta = 8192 is 1 secs
Time to commit t_com (excluded from lookup time) in 149ms
Committed f_com in 0ms
Using update = true
Time for divisions = 0
Computed update params in 0 secs
Time for sub-products = 0
Time for divisions = 0
Computed oracles on set I in 0 secs
Interpolated q polynomial in 0 secs
Time for sub-products = 0
Time for divisions = 0
Evaluated q_dvt on I in 0 secs
Computing b_vec over I took 34 msec
Time for divisions = 1
Computed update params in 1 secs
Time for sub-products = 0
Time for divisions = 0
Computed oracles on set I in 0 secs
Interpolated q polynomial in 0 secs
Time for sub-products = 0
Time for divisions = 0
Evaluated q_dvt on I in 0 secs
Computing a_vec over K took 3070 msec
Time taken: 0
Time for sub-products = 0
Time for divisions = 0
Evaluating Z_I'(X) over I took 7 msec
Time for divisions = 0
Evaluating Z_I(X) over K took 248 msec
Time taken: 0
Time for sub-products = 0
Time for divisions = 0
Interpolating C(X) took 18 msec
Time for divisions = 0
Evaluating C(X) over K took 250 msec
Scalar computation took 3868 msec
MSM took 223 msecs
Proof Generation Time for table=2097152 and batch=256 and delta=8192: 4.121913101 secs
===> Average (finish at delta=8192) lookup time (without table init time) for table=2097152 and batch=256 is 1.6329924822922248 secs
Time to generate example for delta = 16384 is 1 secs
Time to commit t_com (excluded from lookup time) in 252ms
Committed f_com in 11ms
Using update = true
Time for divisions = 0
Computed update params in 0 secs
Time for sub-products = 0
Time for divisions = 0
Computed oracles on set I in 0 secs
Interpolated q polynomial in 0 secs
Time for sub-products = 0
Time for divisions = 0
Evaluated q_dvt on I in 0 secs
Computing b_vec over I took 33 msec
Time for divisions = 3
Computed update params in 4 secs
Time for sub-products = 0
Time for divisions = 0
Computed oracles on set I in 0 secs
Interpolated q polynomial in 1 secs
Time for sub-products = 0
Time for divisions = 0
Evaluated q_dvt on I in 0 secs
Computing a_vec over K took 6756 msec
Time taken: 0
Time for sub-products = 0
Time for divisions = 0
Evaluating Z_I'(X) over I took 7 msec
Time for divisions = 0
Evaluating Z_I(X) over K took 492 msec
Time taken: 0
Time for sub-products = 0
Time for divisions = 0
Interpolating C(X) took 18 msec
Time for divisions = 0
Evaluating C(X) over K took 492 msec
Scalar computation took 8271 msec
MSM took 408 msecs
Proof Generation Time for table=2097152 and batch=256 and delta=16384: 8.788168365 secs
===> Average (finish at delta=16384) lookup time (without table init time) for table=2097152 and batch=256 is 3.2077884037546522 secs
Time to generate example for delta = 32768 is 1 secs
Time to commit t_com (excluded from lookup time) in 506ms
Committed f_com in 12ms
Using update = true
Time for divisions = 0
Computed update params in 0 secs
Time for sub-products = 0
Time for divisions = 0
Computed oracles on set I in 0 secs
Interpolated q polynomial in 0 secs
Time for sub-products = 0
Time for divisions = 0
Evaluated q_dvt on I in 0 secs
Computing b_vec over I took 36 msec
Time for divisions = 7
Computed update params in 9 secs
Time for sub-products = 0
Time for divisions = 1
Computed oracles on set I in 1 secs
Interpolated q polynomial in 2 secs
Time for sub-products = 0
Time for divisions = 1
Evaluated q_dvt on I in 1 secs
Computing a_vec over K took 15027 msec
Time taken: 0
Time for sub-products = 0
Time for divisions = 0
Evaluating Z_I'(X) over I took 7 msec
Time for divisions = 0
Evaluating Z_I(X) over K took 990 msec
Time taken: 0
Time for sub-products = 0
Time for divisions = 0
Interpolating C(X) took 19 msec
Time for divisions = 0
Evaluating C(X) over K took 989 msec
Scalar computation took 18005 msec
MSM took 631 msecs
Proof Generation Time for table=2097152 and batch=256 and delta=32768: 18.786998137 secs
===> Average (finish at delta=32768) lookup time (without table init time) for table=2097152 and batch=256 is 6.530843292477482 secs
Time to generate example for delta = 65536 is 1 secs
Time to commit t_com (excluded from lookup time) in 844ms
Committed f_com in 12ms
Using update = true
Time for divisions = 0
Computed update params in 0 secs
Time for sub-products = 0
Time for divisions = 0
Computed oracles on set I in 0 secs
Interpolated q polynomial in 0 secs
Time for sub-products = 0
Time for divisions = 0
Evaluated q_dvt on I in 0 secs
Computing b_vec over I took 35 msec
Time for divisions = 16
Computed update params in 21 secs
Time for sub-products = 0
Time for divisions = 2
Computed oracles on set I in 3 secs
Interpolated q polynomial in 5 secs
Time for sub-products = 0
Time for divisions = 2
Evaluated q_dvt on I in 2 secs
Computing a_vec over K took 33410 msec
Time taken: 0
Time for sub-products = 0
Time for divisions = 0
Evaluating Z_I'(X) over I took 7 msec
Time for divisions = 1
Evaluating Z_I(X) over K took 1972 msec
Time taken: 0
Time for sub-products = 0
Time for divisions = 0
Interpolating C(X) took 20 msec
Time for divisions = 1
Evaluating C(X) over K took 1979 msec
Scalar computation took 39291 msec
MSM took 1198 msecs
Proof Generation Time for table=2097152 and batch=256 and delta=65536: 40.70029974 secs
===> Average (finish at delta=65536) lookup time (without table init time) for table=2097152 and batch=256 is 13.710636363012158 secs
Time to generate example for delta = 131072 is 1 secs
Time to commit t_com (excluded from lookup time) in 1530ms
Committed f_com in 12ms
Using update = true
Time for divisions = 0
Computed update params in 0 secs
Time for sub-products = 0
Time for divisions = 0
Computed oracles on set I in 0 secs
Interpolated q polynomial in 0 secs
Time for sub-products = 0
Time for divisions = 0
Evaluated q_dvt on I in 0 secs
Computing b_vec over I took 36 msec
Time for divisions = 37
Computed update params in 47 secs
Time for sub-products = 0
Time for divisions = 5
Computed oracles on set I in 6 secs
Interpolated q polynomial in 12 secs
Time for sub-products = 0
Time for divisions = 5
Evaluated q_dvt on I in 5 secs
Computing a_vec over K took 74360 msec
Time taken: 0
Time for sub-products = 0
Time for divisions = 0
Evaluating Z_I'(X) over I took 7 msec
Time for divisions = 4
Evaluating Z_I(X) over K took 4162 msec
Time taken: 0
Time for sub-products = 0
Time for divisions = 0
Interpolating C(X) took 22 msec
Time for divisions = 4
Evaluating C(X) over K took 4162 msec
Scalar computation took 86545 msec
MSM took 2274 msecs
Proof Generation Time for table=2097152 and batch=256 and delta=131072: 89.163843428 secs
===> Average (finish at delta=131072) lookup time (without table init time) for table=2097152 and batch=256 is 29.4608136243199 secs
Time to generate example for delta = 262144 is 1 secs
Time to commit t_com (excluded from lookup time) in 3200ms
Committed f_com in 12ms
Using update = true
Time for divisions = 0
Computed update params in 0 secs
Time for sub-products = 0
Time for divisions = 0
Computed oracles on set I in 0 secs
Interpolated q polynomial in 0 secs
Time for sub-products = 0
Time for divisions = 0
Evaluated q_dvt on I in 0 secs
Computing b_vec over I took 38 msec
Time for divisions = 85
Computed update params in 107 secs
Time for sub-products = 0
Time for divisions = 11
Computed oracles on set I in 14 secs
Interpolated q polynomial in 27 secs
Time for sub-products = 0
Time for divisions = 11
Evaluated q_dvt on I in 11 secs
Computing a_vec over K took 163926 msec
Time taken: 0
Time for sub-products = 0
Time for divisions = 0
Evaluating Z_I'(X) over I took 8 msec
Time for divisions = 8
Evaluating Z_I(X) over K took 8118 msec
Time taken: 0
Time for sub-products = 0
Time for divisions = 0
Interpolating C(X) took 22 msec
Time for divisions = 8
Evaluating C(X) over K took 8092 msec
Scalar computation took 187690 msec
MSM took 3911 msecs
Proof Generation Time for table=2097152 and batch=256 and delta=262144: 192.213225043 secs
===> Average (finish at delta=262144) lookup time (without table init time) for table=2097152 and batch=256 is 63.14594936117937 secs
Time to generate example for delta = 524288 is 1 secs
Time to commit t_com (excluded from lookup time) in 6420ms
Committed f_com in 12ms
Using update = true
Time for divisions = 0
Computed update params in 0 secs
Time for sub-products = 0
Time for divisions = 0
Computed oracles on set I in 0 secs
Interpolated q polynomial in 0 secs
Time for sub-products = 0
Time for divisions = 0
Evaluated q_dvt on I in 0 secs
Computing b_vec over I took 38 msec
Time for divisions = 192
Computed update params in 240 secs
Time for sub-products = 0
Time for divisions = 24
Computed oracles on set I in 31 secs
Interpolated q polynomial in 59 secs
Time for sub-products = 0
Time for divisions = 24
Evaluated q_dvt on I in 24 secs
Computing a_vec over K took 362927 msec
Time taken: 0
Time for sub-products = 0
Time for divisions = 0
Evaluating Z_I'(X) over I took 8 msec
Time for divisions = 16
Evaluating Z_I(X) over K took 16251 msec
Time taken: 0
Time for sub-products = 0
Time for divisions = 0
Interpolating C(X) took 23 msec
Time for divisions = 16
Evaluating C(X) over K took 16681 msec
Scalar computation took 410980 msec
MSM took 7557 msecs
Proof Generation Time for table=2097152 and batch=256 and delta=524288: 419.654771549 secs
===> Average (finish at delta=524288) lookup time (without table init time) for table=2097152 and batch=256 is 136.90152131443867 secs
Time to generate example for delta = 1048576 is 4 secs
Time to commit t_com (excluded from lookup time) in 12034ms
Committed f_com in 12ms
Using update = true
Time for divisions = 0
Computed update params in 0 secs
Time for sub-products = 0
Time for divisions = 0
Computed oracles on set I in 0 secs
Interpolated q polynomial in 0 secs
Time for sub-products = 0
Time for divisions = 0
Evaluated q_dvt on I in 0 secs
Computing b_vec over I took 39 msec
Time for divisions = 422
Computed update params in 526 secs
Time for sub-products = 0
Time for divisions = 43
Computed oracles on set I in 50 secs
Interpolated q polynomial in 127 secs
Time for sub-products = 0
Time for divisions = 53
Evaluated q_dvt on I in 53 secs
Computing a_vec over K took 763546 msec
Time taken: 0
Time for sub-products = 0
Time for divisions = 0
Evaluating Z_I'(X) over I took 7 msec
Time for divisions = 32
Evaluating Z_I(X) over K took 32455 msec
Time taken: 0
Time for sub-products = 0
Time for divisions = 0
Interpolating C(X) took 23 msec
Time for divisions = 31
Evaluating C(X) over K took 31886 msec
Scalar computation took 858107 msec
MSM took 14480 msecs
Proof Generation Time for table=2097152 and batch=256 and delta=1048576: 874.825460864 secs
===> Average (finish at delta=1048576) lookup time (without table init time) for table=2097152 and batch=256 is 287.62567005453974 secs
===> Average (finish at delta=table) lookup time (without table init time) for table=2097152 and batch=256 is 287.62567005453974 secs
Running setup for table size 4194304 and batch size 1024
time to setup powers = 328.970870377s
dummy pp setup takes 334 seconds
dummy table init takes 2 seconds
Time to generate example for delta = 1024 is 2 secs
Time to commit t_com (excluded from lookup time) in 25ms
Committed f_com in 31ms
Using update = true
Time for divisions = 0
Computed update params in 0 secs
Time for sub-products = 0
Time for divisions = 0
Computed oracles on set I in 0 secs
Interpolated q polynomial in 0 secs
Time for sub-products = 0
Time for divisions = 0
Evaluated q_dvt on I in 0 secs
Computing b_vec over I took 198 msec
Time for divisions = 0
Computed update params in 0 secs
Time for sub-products = 0
Time for divisions = 0
Computed oracles on set I in 0 secs
Interpolated q polynomial in 0 secs
Time for sub-products = 0
Time for divisions = 0
Evaluated q_dvt on I in 0 secs
Computing a_vec over K took 373 msec
Time taken: 0
Time for sub-products = 0
Time for divisions = 0
Evaluating Z_I'(X) over I took 52 msec
Time for divisions = 0
Evaluating Z_I(X) over K took 52 msec
Time taken: 0
Time for sub-products = 0
Time for divisions = 0
Interpolating C(X) took 103 msec
Time for divisions = 0
Evaluating C(X) over K took 108 msec
Scalar computation took 1013 msec
MSM took 47 msecs
Proof Generation Time for table=4194304 and batch=1024 and delta=1024: 1.258943648 secs
===> Average (finish at delta=1024) lookup time (without table init time) for table=4194304 and batch=1024 is 1.258943648 secs
Time to generate example for delta = 2048 is 2 secs
Time to commit t_com (excluded from lookup time) in 45ms
Committed f_com in 0ms
Using update = true
Time for divisions = 0
Computed update params in 0 secs
Time for sub-products = 0
Time for divisions = 0
Computed oracles on set I in 0 secs
Interpolated q polynomial in 0 secs
Time for sub-products = 0
Time for divisions = 0
Evaluated q_dvt on I in 0 secs
Computing b_vec over I took 194 msec
Time for divisions = 0
Computed update params in 0 secs
Time for sub-products = 0
Time for divisions = 0
Computed oracles on set I in 0 secs
Interpolated q polynomial in 0 secs
Time for sub-products = 0
Time for divisions = 0
Evaluated q_dvt on I in 0 secs
Computing a_vec over K took 706 msec
Time taken: 0
Time for sub-products = 0
Time for divisions = 0
Evaluating Z_I'(X) over I took 52 msec
Time for divisions = 0
Evaluating Z_I(X) over K took 150 msec
Time taken: 0
Time for sub-products = 0
Time for divisions = 0
Interpolating C(X) took 99 msec
Time for divisions = 0
Evaluating C(X) over K took 255 msec
Scalar computation took 1660 msec
MSM took 66 msecs
Proof Generation Time for table=4194304 and batch=1024 and delta=2048: 1.754915209 secs
===> Average (finish at delta=2048) lookup time (without table init time) for table=4194304 and batch=1024 is 1.5069294285000001 secs
Time to generate example for delta = 4096 is 2 secs
Time to commit t_com (excluded from lookup time) in 88ms
Committed f_com in 34ms
Using update = true
Time for divisions = 0
Computed update params in 0 secs
Time for sub-products = 0
Time for divisions = 0
Computed oracles on set I in 0 secs
Interpolated q polynomial in 0 secs
Time for sub-products = 0
Time for divisions = 0
Evaluated q_dvt on I in 0 secs
Computing b_vec over I took 199 msec
Time for divisions = 0
Computed update params in 0 secs
Time for sub-products = 0
Time for divisions = 0
Computed oracles on set I in 0 secs
Interpolated q polynomial in 0 secs
Time for sub-products = 0
Time for divisions = 0
Evaluated q_dvt on I in 0 secs
Computing a_vec over K took 1473 msec
Time taken: 0
Time for sub-products = 0
Time for divisions = 0
Evaluating Z_I'(X) over I took 52 msec
Time for divisions = 0
Evaluating Z_I(X) over K took 346 msec
Time taken: 0
Time for sub-products = 0
Time for divisions = 0
Interpolating C(X) took 103 msec
Time for divisions = 0
Evaluating C(X) over K took 556 msec
Scalar computation took 3087 msec
MSM took 121 msecs
Proof Generation Time for table=4194304 and batch=1024 and delta=4096: 3.429045996 secs
===> Average (finish at delta=4096) lookup time (without table init time) for table=4194304 and batch=1024 is 2.1933996311785715 secs
Time to generate example for delta = 8192 is 2 secs
Time to commit t_com (excluded from lookup time) in 149ms
Committed f_com in 33ms
Using update = true
Time for divisions = 0
Computed update params in 0 secs
Time for sub-products = 0
Time for divisions = 0
Computed oracles on set I in 0 secs
Interpolated q polynomial in 0 secs
Time for sub-products = 0
Time for divisions = 0
Evaluated q_dvt on I in 0 secs
Computing b_vec over I took 206 msec
Time for divisions = 1
Computed update params in 1 secs
Time for sub-products = 0
Time for divisions = 0
Computed oracles on set I in 0 secs
Interpolated q polynomial in 0 secs
Time for sub-products = 0
Time for divisions = 0
Evaluated q_dvt on I in 0 secs
Computing a_vec over K took 3169 msec
Time taken: 0
Time for sub-products = 0
Time for divisions = 0
Evaluating Z_I'(X) over I took 52 msec
Time for divisions = 0
Evaluating Z_I(X) over K took 743 msec
Time taken: 0
Time for sub-products = 0
Time for divisions = 0
Interpolating C(X) took 104 msec
Time for divisions = 1
Evaluating C(X) over K took 1158 msec
Scalar computation took 6099 msec
MSM took 223 msecs
Proof Generation Time for table=4194304 and batch=1024 and delta=8192: 6.551061089 secs
===> Average (finish at delta=8192) lookup time (without table init time) for table=4194304 and batch=1024 is 3.4526451543375005 secs
Time to generate example for delta = 16384 is 2 secs
Time to commit t_com (excluded from lookup time) in 251ms
Committed f_com in 32ms
Using update = true
Time for divisions = 0
Computed update params in 0 secs
Time for sub-products = 0
Time for divisions = 0
Computed oracles on set I in 0 secs
Interpolated q polynomial in 0 secs
Time for sub-products = 0
Time for divisions = 0
Evaluated q_dvt on I in 0 secs
Computing b_vec over I took 203 msec
Time for divisions = 3
Computed update params in 4 secs
Time for sub-products = 0
Time for divisions = 0
Computed oracles on set I in 0 secs
Interpolated q polynomial in 1 secs
Time for sub-products = 0
Time for divisions = 0
Evaluated q_dvt on I in 0 secs
Computing a_vec over K took 6930 msec
Time taken: 0
Time for sub-products = 0
Time for divisions = 0
Evaluating Z_I'(X) over I took 52 msec
Time for divisions = 1
Evaluating Z_I(X) over K took 1548 msec
Time taken: 0
Time for sub-products = 0
Time for divisions = 0
Interpolating C(X) took 107 msec
Time for divisions = 2
Evaluating C(X) over K took 2395 msec
Scalar computation took 12527 msec
MSM took 412 msecs
Proof Generation Time for table=4194304 and batch=1024 and delta=16384: 13.185303867 secs
===> Average (finish at delta=16384) lookup time (without table init time) for table=4194304 and batch=1024 is 5.904808929793096 secs
Time to generate example for delta = 32768 is 2 secs
Time to commit t_com (excluded from lookup time) in 530ms
Committed f_com in 34ms
Using update = true
Time for divisions = 0
Computed update params in 0 secs
Time for sub-products = 0
Time for divisions = 0
Computed oracles on set I in 0 secs
Interpolated q polynomial in 0 secs
Time for sub-products = 0
Time for divisions = 0
Evaluated q_dvt on I in 0 secs
Computing b_vec over I took 204 msec
Time for divisions = 7
Computed update params in 9 secs
Time for sub-products = 0
Time for divisions = 1
Computed oracles on set I in 1 secs
